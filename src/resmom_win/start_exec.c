/*
 * Copyright (C) 1994-2017 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *  
 * This file is part of the PBS Professional ("PBS Pro") software.
 * 
 * Open Source License Information:
 *  
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free 
 * Software Foundation, either version 3 of the License, or (at your option) any 
 * later version.
 *  
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU Affero General Public License for more details.
 *  
 * You should have received a copy of the GNU Affero General Public License along 
 * with this program.  If not, see <http://www.gnu.org/licenses/>.
 *  
 * Commercial License Information: 
 * 
 * The PBS Pro software is licensed under the terms of the GNU Affero General 
 * Public License agreement ("AGPL"), except where a separate commercial license 
 * agreement for PBS Pro version 14 or later has been executed in writing with Altair.
 *  
 * Altair’s dual-license business model allows companies, individuals, and 
 * organizations to create proprietary derivative works of PBS Pro and distribute 
 * them - whether embedded or bundled with other software - under a commercial 
 * license agreement.
 * 
 * Use of Altair’s trademarks, including but not limited to "PBS™", 
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's 
 * trademark licensing policies.
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#ifndef WIN32
#include <stdlib.h>
#include <unistd.h>
#include <dirent.h>
#include <pwd.h>
#include <grp.h>
#include <termios.h>
#include <sys/param.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>

#if defined(__osf__)
#include <stropts.h>
#endif


#ifdef        sgi
#include <sys/syssgi.h>
#endif        /* sgi */

#endif

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <string.h>
#include <limits.h>
#include <assert.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <Userenv.h>

#include "libpbs.h"
#include "list_link.h"

#ifndef WIN32
#include "portability.h"
#else
#include "win.h"
#endif

#include "server_limits.h"
#include "attribute.h"
#include "resource.h"
#include "job.h"
#include "log.h"
#include "rpp.h"
#include "dis.h"
#include "pbs_nodes.h"
#include "mom_mach.h"
#include "mom_func.h"
#include "pbs_error.h"
#include "net_connect.h"
#include "batch_request.h"

#include "credential.h"
#include "ticket.h"
#include "svrfunc.h"
#include "libsec.h"
#include "mom_hook_func.h"
#include "pbs_internal.h"


#define EXTRA_ENV_PTRS	       32

/**
 * @file
 */
/* Global Variables */

extern  int		num_var_env;
extern	char	      **environ;
extern	int		exiting_tasks;
extern	u_long		localaddr;
extern	pbs_list_head	mom_polljobs;
extern	int		next_sample_time;
extern	int		min_check_poll;
extern	char		*path_checkpoint;
extern	char		*path_jobs;
extern	char		*path_prolog;
extern	char		*path_spool;
extern	unsigned int	pbs_rm_port;
extern	gid_t		pbsgroup;
extern	int		server_stream;
extern	unsigned int	pbs_mom_port;
extern	time_t		time_now;
extern	time_t		time_resc_updated;
extern	char		mom_host[];
extern char             *mom_home;
extern int enable_exechost2;

int              mom_reader_go;		/* see catchinter() & mom_writer() */

#ifndef WIN32
extern	int	  lockfds;
struct	var_table vtable;

#endif

static int set_credential(job *, char **, char ***);

extern eventent * event_dup(eventent *ep, job *pjob, hnodent *pnode);
extern void send_join_job_restart_mcast(int mtfd, int com, eventent *ep, int nth, job *pjob, pbs_list_head *phead);

/* Local Varibles */

#ifdef WIN32
int		 	script_out;
int			script_err;
#endif

static int	 script_in;	/* script file, will be stdin	  */
static pid_t	 writerpid;	/* writer side of interactive job */
static pid_t	 shellpid;	/* shell part of interactive job  */
static int       cred_type;
static size_t    cred_len;
static char     *cred_buf;

char *variables_else[] = {	/* variables to add, value computed */
	"HOME",
	"LOGNAME",
	"PBS_JOBNAME",
	"PBS_JOBID",
	"PBS_QUEUE",
	"SHELL",
	"USER",
	"PBS_JOBCOOKIE",
	"PBS_NODENUM",
	"PBS_TASKNUM",
	"PBS_MOMPORT",
	"PBS_NODEFILE",
	"OMP_NUM_THREADS",
	"PBS_ACCOUNT",
	"PBS_ARRAY_INDEX",
	"PBS_ARRAY_ID",
	"USERPROFILE",
	"USERNAME"
};

static	int num_var_else = sizeof(variables_else) / sizeof(char *);

static	void
starter_return(int upfds, int downfds, int code,
	struct startjob_rtn *);
static	void catchinter(int);

#define FDMOVE(fd)      if (fd < 3) { \
	int     hold = fcntl(fd, F_DUPFD, 3); \
	(void)close(fd); \
	fd = hold; \
}

/**
 * @brief
 *      Internal error routine.
 *
 * @param[in] string - error related to
 * @param[in] value - error number
 *
 * @return      int
 * @retval      error number
 *
 */
int
error(char *string, int value)
{
	int		i = 0;
	char		*message;
	extern char	*msg_momsetlim;
	extern struct	pbs_err_to_txt	pbs_err_to_txt[];

	assert(string != NULL);
	assert(*string != '\0');
	assert(value > PBSE_);			/* minimum PBS error number */
	assert(value <= PBSE_NOSYNCMSTR);	/* maximum PBS error number */
	assert(pbs_err_to_txt[i].err_no != 0);

	do {
		if (pbs_err_to_txt[i].err_no == value)
			break;
	} while (pbs_err_to_txt[++i].err_no != 0);

	assert(pbs_err_to_txt[i].err_txt != NULL);
	message = *pbs_err_to_txt[i].err_txt;
	assert(message != NULL);
	assert(*message != '\0');

	if (value == PBSE_SYSTEM) {
		strcpy(log_buffer, message);
		strcat(log_buffer, strerror(errno));
		message = log_buffer;
	}
	(void)fprintf(stderr, msg_momsetlim, string, message);
	(void)fflush(stderr);

	return value;
}

/**
 * @brief
 *      is_joined - determine if stdard out and stardard error are joined together
 *      (-j option) and if so which is first
 *
 * @param[in] pjob - job pointer
 *
 * @return      int
 * @retval      0       no join, separate files
 * @retval      +1      joined as stdout
 * @retval      -1      joined as stderr
 *
 */
int
is_joined(job *pjob)
{
	attribute *pattr;

	pattr = &pjob->ji_wattr[(int)JOB_ATR_join];
	if ((pattr->at_flags & ATR_VFLAG_SET) &&
		(pattr->at_val.at_str[0] != 'n')) {
		if ((pattr->at_val.at_str[0] == 'o') &&
			(strchr(pattr->at_val.at_str, (int)'e') != 0)) {
			return 1;
		} else if ((pattr->at_val.at_str[0] == 'e') &&
			(strchr(pattr->at_val.at_str, (int)'e') != 0)) {
			return -1;
		}
	}
	return 0;
}

#define	RETRY	3

/**
 * @brief
 *      opens the demux
 *
 * @param[in] addr - ip address
 * @param[in] port - port number
 *
 * @return      int
 * @retval      -1              Error
 * @retval      socket number   Success
 *
 */
int
open_demux(u_long addr, int port)
{
	int	sock;
	int	i;
	struct	sockaddr_in	remote;

	remote.sin_addr.s_addr = addr;
	remote.sin_port = htons((unsigned short)port);
	remote.sin_family = AF_INET;

#ifdef WIN32
	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
#else
	if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
#endif
	{
		sprintf(log_buffer, "%s: socket %s", __func__, netaddr(&remote));
		log_err(errno, __func__, log_buffer);
		return -1;
	}

	for (i=0; i<RETRY; i++) {
		if (connect(sock, (struct sockaddr *)&remote,
			sizeof(remote)) == 0)
			return sock;

		switch (errno) {

#ifdef WIN32
			case WSAEINTR:
			case WSAEADDRINUSE:
			case WSAETIMEDOUT:
			case WSAECONNREFUSED:
				Sleep(2000);
#else
			case EINTR:
			case EADDRINUSE:
			case ETIMEDOUT:
			case ECONNREFUSED:
				sleep(2);
#endif
				continue;

			default:
				break;
		}
		break;
	}
	sprintf(log_buffer, "%s: connect %s", __func__, netaddr(&remote));
	log_err(errno, __func__, log_buffer);

#ifdef WIN32
	(void)closesocket(sock);
#else
	(void)close(sock);
#endif
	return -1;
}

/**
 * @brief
 *      returns shell name
 *
 * @param[in] shell - shellname
 *
 * @return      string
 * @retval      shell name
 *
 */
char *
lastname(char *shell)
{
	char	*shellname;

	shellname = strrchr(shell, '/');
	if (shellname)
		shellname++;	/* go past last '/' */
	else
		shellname = shell;
	return shellname;
}

/**
 * @brief
 *      tmpdirname - build a temporary directory name
 *
 * @param[in] sequence - directory name
 *
 * @return      string
 * @retval      directory name
 *
 */
char *
tmpdirname(char *sequence)
{
	static char tmpdir[MAXPATHLEN+1];

#ifdef WIN32
	struct stat sb;
	char    str_buf[MAXPATHLEN+1] = {0};

	/*
	 * use C:\WINNT\TEMP or C:\WINDOWS\TEMP,
	 * or 'path_spool', if $tmpdir is not present.
	 * PBS on Windows must return an existing temp
	 * directory (like Linux/Unix's /tmp) to place
	 * user temp dirs; otherwise, jobs would fail to start.
	 */

	if (stat(pbs_tmpdir, &sb) == -1) {
		if (stat("C:\\WINNT\\TEMP", &sb) == 0)
			strcpy(pbs_tmpdir, "C:\\WINNT\\TEMP");
		else if (stat("C:\\WINDOWS\\TEMP", &sb) == 0)
			strcpy(pbs_tmpdir, "C:\\WINDOWS\\TEMP");
		else {
			replace(path_spool, "/", "\\", str_buf);
			strcpy(pbs_tmpdir, str_buf);
		}
	}
	sprintf(tmpdir, "%s\\pbs.%s", pbs_tmpdir, sequence);
#else
	sprintf(tmpdir, "%s/pbs.%s", pbs_tmpdir, sequence);
#endif
	return tmpdir;
}

/**
 * @brief
 *      jobdirname - build the staging and execution directory name
 *      with a random number tagged onto the end
 *
 * @param[in] sequence - directory name
 * @param[in] homedir - home dirctory
 *
 * @return      string
 * @retval      job directory name      success
 *
 */

char *
jobdirname(char *sequence, char *homedir)
{
	static char dir[MAXPATHLEN+1];
	char	    pbs_jobdir[MAXPATHLEN+1];

#ifdef WIN32
	struct stat sb;
	char   str_buf[MAXPATHLEN+1] = {0};

	if (pbs_jobdir_root[0] != '\0') {
		/* jobdir_root is in the mom_priv/config file */
		strcpy(pbs_jobdir, pbs_jobdir_root);

	} else if ((homedir != NULL) && (*homedir != '\0')) {
		/*
		 * jobdir_root was not set in mom_priv/config file
		 * so use the given homedir
		 */
		strcpy(pbs_jobdir, homedir);

	} else {
		/* last resort, use tmp */
		if (stat("C:\\WINNT\\TEMP", &sb) == 0)
			strcpy(pbs_jobdir, "C:\\WINNT\\TEMP");
		else if (stat("C:\\WINDOWS\\TEMP", &sb) == 0)
			strcpy(pbs_jobdir, "C:\\WINDOWS\\TEMP");
		else {
			replace(path_spool, "/", "\\", str_buf);
			strcpy(pbs_jobdir, str_buf);
		}
	}

	if (pbs_jobdir[strlen(pbs_jobdir)-1] == '\\') {
		sprintf(dir, "%spbs.%s.%s", pbs_jobdir, sequence, FAKE_RANDOM);
	} else {
		sprintf(dir, "%s\\pbs.%s.%s", pbs_jobdir, sequence, FAKE_RANDOM);
	}

#else
	/* UNIX */
	if (pbs_jobdir_root[0] != '\0') {
		sprintf(dir, "%s/pbs.%s.%s", pbs_jobdir_root, sequence, FAKE_RANDOM);
	} else if ((homedir != NULL) && (*homedir != '\0')) {
		/*
		 * jobdir_root was not set in mom_priv/config file
		 * so use the given homedir
		 */
		sprintf(dir, "%s/pbs.%s.%s", homedir, sequence, FAKE_RANDOM);
	} else {
		/* last resort, use default tmp dir */
		sprintf(dir, "%s/pbs.%s.%s", pbs_tmpdir, sequence, FAKE_RANDOM);
	}

#endif

	return dir;
}

/**
 * @brief
 *      rmtmpdir - remove the temporary directory
 *      This may take awhile so the task is forked and execed to another
 *      process.
 *
 * @param[in] jobid - job id
 *
 * @return      Void
 *
 */
void
rmtmpdir(char *jobid)
{
	static	char	rmdir[MAXPATHLEN+1];
	struct	stat	sb;
	char	*rm = "/bin/rm";
	char	*rf = "-rf";
	char	*tmpdir;
	char	*newdir = rmdir;

#ifdef WIN32
	struct 	pio_handles pio;
	char	cmdbuf[MAXPATHLEN+1];
#else
	pid_t	pid;
#endif

	/* Hello, is any body there? */
	tmpdir = tmpdirname(jobid);
	if (stat(tmpdir, &sb) == -1) {
		if (errno != ENOENT) {
			sprintf(log_buffer, "stat: %s", tmpdir);
			log_joberr(errno, __func__, log_buffer, jobid);
		}
		return;
	}

#ifdef WIN32
	if (pbs_tmpdir[strlen(pbs_tmpdir)-1] == '\\')
		sprintf(rmdir, "%spbs_remove.%s", pbs_tmpdir, jobid);
	else
		sprintf(rmdir, "%s\\pbs_remove.%s", pbs_tmpdir, jobid);
#else
	sprintf(rmdir, "%s/pbs_remove.%s", pbs_tmpdir, jobid);
#endif
	if (rename(tmpdir, newdir) == -1) {
		sprintf(log_buffer, "%s %s", tmpdir, newdir);
		log_joberr(errno, __func__, log_buffer, jobid);
		newdir = tmpdir;
	}

#ifdef WIN32
	sprintf(cmdbuf, "rmdir /S /Q \"%s\"", newdir);
	if (!win_popen(cmdbuf, "w", &pio, NULL)) {
		errno = GetLastError();
		log_joberr(errno, __func__, "win_popen", jobid);
	}
	win_pclose2(&pio);
	close_valid_handle(&(pio.pi.hProcess));
#else
	/* fork and exec the cleantmp process */
	pid = fork();
	if (pid < 0) {
		log_err(errno, __func__, "fork");
		return;
	}

	if (pid > 0)		/* parent */
		return;

	rpp_terminate();
	execl(rm, "pbs_cleandir", rf, newdir, (char *)0);
	log_err(errno, __func__, "execl");
	exit(21);
#endif
}

#ifdef WIN32	/* WIN32 ------------------------------------------------- */
#define ENV_BUFSIZE	8192
static	char	**env_array = NULL;
static	int	curenv = 0;
static	int	numenv = 0;

int
compare(const void *arg1, const void *arg2)
{
	return strcmp(*(char **)arg1, *(char **)arg2);
}

/**
 * @brief
 * 	init_envp: initializes the storage that stores set environment variables 
 * 
 */
void
init_envp()
{
	int	i;

	if ((env_array == NULL) || curenv == 0)
		return;

	for (i=0; i<curenv; i++) {
		if (env_array[i])
			(void)free(env_array[i]);
	}

	env_array = NULL;
	curenv = 0; /* no variables in the env_array */

	return;
}

char	*
make_envp()
{
	int	i;
	size_t	len = 0;
	char	*envp, *cp;

	if (curenv == 0)
		return NULL;

	qsort((void *)env_array, (size_t)curenv, sizeof(char *), compare);

	for (i=0; i<curenv; i++)
		len += (strlen(env_array[i]) + 1);
	len++;

	envp = cp = (char *)malloc(len);
	if (cp == NULL) {
		return NULL;
	}
	for (i=0; i<curenv; i++) {
		len = strlen(env_array[i]);
		memcpy(cp, env_array[i], len);
		cp += len;
		*cp++ = '\0';
	}
	*cp = '\0';
	curenv = 0;
	return envp;
}

/**
 * @brief
 *      find_env_slot - find if the environment variable is already in the table,
 *      If so, replace the existing one with the new one.
 *
 * @param[in] ptbl - pointer to var_table which holds environment variable for job
 * @param[in] pstr - new environment variable
 *
 * @return      int
 * @retval      !(-1)   success
 * @retval      -1      Failure
 *
 */
static int
find_wenv_slot(char *name)
{
	int	 i;
	int	 len = 1;	/* one extra for '=' */

	if (name == NULL)
		return (-1);
	for (i=0; (*(name+i) != '=') && (*(name+i) != '\0'); ++i)
		++len;

	for (i=0; i<curenv; ++i) {
		if (strncmp(env_array[i], name, len) == 0)
			return (i);
	}
	return (-1);
}

/**
 * @brief
 *      bld_env_variables - Add an entry to the table that defines the environment variables for a job.
 *
 *@par	Note:
 *	Value may be null if total string (name=value) is included in "name".
 *
 * @param[in] name - variable name alone or a "name=value" string
 * @param[in] value - variable value or NULL if name contains "name=value"
 *
 * @return - None
 *
 */
void
bld_wenv_variables(char *name, char *value)
{
	char	*env;
	int	amt;
	int	i;
	char    str_buf[MAXPATHLEN+1] = {0};

	if ((*name == '\0') || (*name == '\n'))
		return;			/* invalid name */

	if (env_array == NULL) {
		numenv = 32;
		env_array = (char **)malloc(sizeof(char *) * numenv);
		if (env_array == NULL) {
			log_err(errno, "bld_wenv_variables", "failed to malloc");
			return;
		}
		/* initialize the unused entries to NULL */
		for (i=0; i < numenv; i++)
			env_array[i] = NULL;
	}
	/* curenv is the index to th next slot that can be used in env_array. */
	/* numenv is the number of elements currently allocated in env_array. */
	if (curenv == numenv) {		/* none left */
		int	numenv_tmp = 0;
		char	**env_array_tmp = NULL;

		numenv_tmp = numenv * 2;
		env_array_tmp = (char **)realloc(env_array, sizeof(char *)*numenv_tmp);
		if (env_array_tmp == NULL) {
			log_err(errno, "bld_wenv_variables",
				"failed to realloc");
			return;
		}
		env_array = env_array_tmp;
		numenv = numenv_tmp;

		/* initialize the unused entries to NULL */
		for (i=curenv; i < numenv; i++) {
			env_array[i] = NULL;
		}
	}

	amt = strlen(name) + 1;			/* plus 1 for nul */
	if (value)
		amt += strlen(value) + 1;	/* plus 1 for "=" */

	env = (char *)malloc(amt);
	if (env == NULL) {
		log_err(errno, "bld_wenv_variables",
			"failed to malloc");
		return;
	}
	(void)strcpy(env, name);
	if (value) {
		(void)strcat(env, "=");
		(void)strcat(env, value);
	}
	if (strnicmp(name, "PATH", 4) == 0 ||
		strnicmp(name, "HOME", 4) == 0 ||
		strnicmp(name, "PBS_NODEFILE", 12) == 0 ||
		strnicmp(name, "PBS_O_HOME", 10) == 0 ||
		strnicmp(name, "PBS_O_PATH", 10) == 0 ||
		strnicmp(name, "USERPROFILE", 11) == 0 ||
		strnicmp(name, "PBS_JOBDIR", 10) == 0 ||
		strnicmp(name, "ComSpec", 7) == 0) {
		forward2back_slash(env);
	} else if (strnicmp(name, "PBS_O_WORKDIR", 13)  == 0) {
		replace(env, "\\ ", " ", str_buf);
		strcpy(env, str_buf);
		forward2back_slash(env);
	}

	if ((i = find_wenv_slot(env)) < 0) {
		/* use an unassigned slot */
		if (env_array[curenv])
			free(env_array[curenv]);
		env_array[curenv] = env;
		curenv++;	/* for next unassigned slot */
	} else  { /* reuse a slot */
		if (env_array[i])
			free(env_array[i]);
		env_array[i] = env;
	}
}

/**
 * @brief
 *      mktmpdir - make temporary directory(s)
 *      A temporary directory is created and the name is
 *      placed in an environment variable.
 *
 * @param[in] jobid - job id
 * @param[in] username - user name
 *
 * @return      int
 * @retval      0               Success
 * @retval      JOB_EXEC_FAIL1  failure to make directory
 *
 */
int
mktmpdir(char *jobid, char *username)
{
	char    *tmpdir;

	tmpdir = tmpdirname(jobid);

	bld_wenv_variables("TMPDIR", tmpdir);
	bld_wenv_variables("TMP", tmpdir);

	if (_mkdir(tmpdir) == -1) {
		errno = GetLastError();
		if (errno == ERROR_ALREADY_EXISTS)
			return 0;
		sprintf(log_buffer, "%s: mkdir: %s",
			jobid, tmpdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	secure_file2(tmpdir,
		username,
		READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED,
		"Administrators", READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED);
	return 0;
}

/**
 * @brief
 * 	mkjobdir - make a staging and execution directory
 *	A per-job staging and execution directory is created and the name is
 *	placed in an environment variable.
 *
 * @param[in]   jobid        - the job id
 * @param[in]   jobdir       - the job's staging and execution directory
 * @param[in]   username     - the user name
 * @param[in]   login_handle - the login handle of user session under which the job directory needs to be created
 *
 * @return      int
 * @retval      0       Success
 * @retval      -1      Error
 *
 */
int
mkjobdir(char *jobid, char *jobdir, char *username, HANDLE login_handle)
{
	/* 
	 * Create the job directory under user session if it is a network path.
	 */
	if(login_handle != INVALID_HANDLE_VALUE) {
		if (is_network_drive_path(jobdir) && impersonate_user(login_handle) == 0) {
			snprintf(log_buffer, sizeof(log_buffer) - 1, "mkjobdir: failed to impersonate user %s error=%d",
				username, GetLastError());
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB,
				LOG_DEBUG, jobid, log_buffer);
			return JOB_EXEC_FAIL1;
		}
	}
	
	if (_mkdir(jobdir) == -1) {
		errno = GetLastError();
		if(login_handle != INVALID_HANDLE_VALUE)
			revert_impersonated_user();
		if (errno == ERROR_ALREADY_EXISTS) {
			sprintf(log_buffer, "the staging and execution directory %s already exists", jobdir);
			log_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_JOB, LOG_INFO, jobid, log_buffer);
			return 0;
		}
		sprintf(log_buffer, "%s: mkdir: %s",
			jobid, jobdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	/* Secure job directory as Admin */
	if(is_network_drive_path(jobdir) && login_handle != INVALID_HANDLE_VALUE)
		(void)revert_impersonated_user();

	secure_file2(jobdir,
		username,
		READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED,
		"Administrators", READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED);

	/* success! log a message showing the name of the staging and execution dir */
	sprintf(log_buffer, "created the job directory %s", jobdir);
	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, jobid, log_buffer);
	return 0;
}

/**
 * @brief
 * 	Given pwdp->pw_dir, save the actual homedir path that results
 *	from mapping to a local drive, using the actual path, or
 *	returning a default, local path in 2 locations:
 *
 * @par 
 *	1. in pjob->ji_wattr[(int)JOB_ATR_altid] as a
 *	"HomeDirectory=<actual_homedir_path>" string (permanent save)
 *
 *	2. in pjob->ji_grpcache->gc_homedir (cache save).
 *
 *	We're saving in 2 locations since ji_grpcache is currently used in
 *	existing code which we don't want to disturb.
 *
 * @return	string
 * @retval	The actual homedir path		success
 * @retval	empty string ("") 		if an error occurred.
 *
 * @par	CAVEAT:
 *	If pjob is NULL, then a default, local homedir path is returned.
 *	if pwdp is NULL, then return an empty string.
 *	If pjob->ji_grpcache is NULL, then it will be recreated along with
 *	pjob->ji_wattr[(int)JOB_ATR_altid] and pjob->ji_grpcache->gc_homedir.
 *	
 *	Otherwise, this function will pick up the current values of
 *	pjob->ji_grpcache->gc_homedir/pjob->ji_wattr[(int)JOB_ATR_altid].
 *
 */

char *
save_actual_homedir(struct passwd *pwdp, job *pjob)
{

	if (pwdp == NULL)
		return ("");

	if (pjob == NULL)
		return (default_local_homedir(pwdp->pw_name,
			pwdp->pw_userlogin, 0));

	if (pjob->ji_grpcache == (struct grpcache *)NULL) {

		char lpath[MAXPATHLEN+1];
		char opath[MAXPATHLEN+15]; /* HomeDirectory=<path>\0 */

		if (pjob->ji_wattr[(int)JOB_ATR_altid].at_flags &
			ATR_VFLAG_SET) {
			char *p;

			p = strstr(pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str, "HomeDirectory=");
			if (p) {
				/* p+14 is the string after HomeDirectory= */
				unmap_unc_path(p+14);
			}
		}

		strncpy(lpath, map_unc_path(pwdp->pw_dir, pwdp), MAXPATHLEN+1);

		/* save permanent copy */
		snprintf(opath, MAXPATHLEN+15, "HomeDirectory=%s", lpath);
		(void)decode_str(&pjob->ji_wattr[JOB_ATR_altid],
			ATTR_altid, NULL, opath);
		update_ajob_status(pjob);

		/* save cache copy */
		pjob->ji_grpcache = malloc(sizeof(struct grpcache) +
			strlen(lpath) + 1);
		if (pjob->ji_grpcache == (struct grpcache *)0)
			return ("");
		strcpy(pjob->ji_grpcache->gc_homedir, lpath);
	}

	return (pjob->ji_grpcache->gc_homedir);

}

/**
 * @brief
 *	set_homedir_to_local_default: if pjob exists, then reset value of 
 * 	pjob->ji_grpcache->gc_homedir to the user's default, local homedir 
 * 	Otherwise find username's default, local homedir 
 *
 * @param[in] pjob - job pointer
 * @param[in] username -user name
 *
 * @return	string
 * @retval	The user's actual default, local homedir path in a static area
 * @retval      empty string (""),if an error occurred.
 *
 */
char *
set_homedir_to_local_default(job *pjob, char *username)
{

	size_t  lsize;
	static  char	lpath[MAXPATHLEN+1];
	struct grpcache *g;

	if (pjob == NULL) {
		struct  passwd *pp = NULL;

		pp = getpwnam(username);

		if ((username == NULL) || (pp == NULL))
			return ("");

		strcpy(lpath, default_local_homedir(username,
			pp->pw_userlogin, 0));
		return (lpath);
	}

	strcpy(lpath, default_local_homedir(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, pjob->ji_user->pw_userlogin, 0));

	lsize = sizeof(struct grpcache) + strlen(lpath) + 1;

	g = pjob->ji_grpcache;

	if ((pjob->ji_grpcache=(struct grpcache *)realloc(g, lsize))) {

		/* if it fails to unmap here, ok since current homedir value */
		/* saved in pjob's altid which will get unmapped when job */
		/* is deleted */
		unmap_unc_path(pjob->ji_grpcache->gc_homedir);

		strcpy(pjob->ji_grpcache->gc_homedir, lpath);
		return (lpath);
	} else {
		pjob->ji_grpcache = g;	/* restore */
		strcpy(pjob->ji_grpcache->gc_homedir, "");
		return ("");
	}
}

/**
 * @brief
 *      validate credentials of user for job.
 *
 * @param[in] pjob - job pointer
 *
 * @return      pointer to structure
 * @retval      structure handle to passwd
 *
 */
struct	passwd *
check_pwd(job *pjob)
{
	struct	passwd *pwdp = pjob->ji_user;
	char	*username = pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str;
	cred_buf = NULL;
	cred_len = 0;
	if (pjob) {
		read_cred(pjob, &cred_buf, &cred_len);
	}

	if (pwdp == NULL) {
		if ((pwdp = \
		  logon_pw(username, cred_buf, cred_len, pbs_decrypt_pwd, 1,
			log_buffer)) == NULL) {
			/* cred_buf wasn't cleared in <= 5.4.1 -  mem leak */
			if (cred_buf) {
				free(cred_buf);
				cred_buf = NULL;
			}

			log_err(-1, "check_pwd", log_buffer);
			return NULL;
		}

		if (strlen(log_buffer) > 0) {
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB,
				LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
		}
		pjob->ji_user = pwdp;
	}

	if (pwdp)
		pjob->ji_qs.ji_un.ji_momt.ji_exuid = pwdp->pw_uid;

	if (pjob->ji_grpcache != (struct grpcache *)NULL) {
		(void)free(pjob->ji_grpcache);
		pjob->ji_grpcache = NULL;
	}

	/* Any kind of mapping is to be done by user */
	if (pwdp->pw_userlogin != INVALID_HANDLE_VALUE) {
		if (impersonate_user(pwdp->pw_userlogin) == 0) {
			sprintf(log_buffer, "warning: failed to impersonate user %s error=%d",
				pwdp->pw_name, GetLastError());
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB,
				LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
		}
	}

	(void)save_actual_homedir(pwdp, pjob);

	(void)revert_impersonated_user();

	if (cred_buf) {
		free(cred_buf);
		cred_buf = NULL;
	}

	return pwdp;
}

/**
 * @brief
 * 	become the user
 *
 * @param[in] pjob - job pointer
 *
 * @return	int
 * @retval	0	success
 * @retval	-1	error
 *
 */

int
becomeuser(job *pjob)
{
	struct passwd *pwdp;

	if ((pwdp = check_pwd(pjob)) == NULL) {
		log_err(-1, __func__, log_buffer);
		return -1;
	}
	if (pwdp->pw_userlogin != INVALID_HANDLE_VALUE) {
		if (!impersonate_user(pwdp->pw_userlogin)) {
			log_err(-1, __func__, "ImpersonateLoggedOnUser");
			return -1;
		}
	}else{
		log_err(-1, __func__, "ImpersonateLoggedOnUser");
		return -1;
	}

	return 0;
}

/**
 * @brief
 *	terminate process tree by using given 
 *	parent process handle <hProcess> and close that handle
 *
 * @param[in] ptask - pointer to task
 *
 * @return	Void
 *
 */
void
proc_bail(task *ptask)
{
	if (script_in != -1) {
		close(script_in);
		script_in = -1;
	}
	if (script_out != -1) {
		close(script_out);
		script_out = -1;
	}
	if (script_err != -1) {
		close(script_err);
		script_err = -1;
	}
	if (ptask != NULL && ptask->ti_hProc != NULL) {
		processtree_op_by_handle(ptask->ti_hProc, TERMINATE, 13);
		CloseHandle(ptask->ti_hProc);
		ptask->ti_hProc = NULL;
	}

	/* restore MOM to its home */
	(void)chdir(mom_home);

	return;
}

/**
 * @brief
 *	exec_bail - called when the start of a job fails to clean up
 *
 * @par Functionality:
 *	Logs the message if one is passed in.
 *	Sends IM_ABORT_JOB to the sisters.
 *	sets the job's substate to JOB_SUBSTATE_EXITING, sets the job's
 *	exit code and sets exiting_tasks so an obit is sent for the job.
 *	The job's standard out/err are closed and then resources are released.
 *
 * @param[in]	pjob - pointer to job structure
 * @param[in]	code - the error code for the exit value, typically JOB_EXEC_*
 * @param[in]	txt  - a message to log or NULL if none or already logged
 *
 * @return	None
 *
 * @par MT-safe: likely no
 */
void
exec_bail(job *pjob, int code, char *txt)
{
	int	nodes;
	task	*ptask = (task *)GET_NEXT(pjob->ji_tasks);

	/* log message passed in if one was */
	if (txt != NULL) {
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, txt);
	}

	nodes = send_sisters(pjob, IM_ABORT_JOB, NULL);
	if (nodes != pjob->ji_numnodes-1) {
		sprintf(log_buffer,
			"sent %d ABORT requests, should be %d",
			nodes, pjob->ji_numnodes-1);
		log_err(-1, __func__, log_buffer);
	}

	pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXITING;
	pjob->ji_qs.ji_un.ji_momt.ji_exitstat = code;
	exiting_tasks = 1;
	proc_bail(ptask);
	if (pjob->ji_hJob != NULL) {
		CloseHandle(pjob->ji_hJob);
		pjob->ji_hJob = NULL;
	}
	return;
}

/**
 * @brief
 *      open_std_out_err - open standard out and err to files
 *
 * @param[in] pjob - job pointer
 *
 * @return      int
 * @retval      0       Success
 * @retval      -1      Error
 *
 */
static int
open_std_out_err(job *pjob)
{
	int	   i;
	int	   filemode = O_CREAT | O_WRONLY | O_APPEND;

	/* if std out/err joined (set and !="n"),which file is first */

	i = is_joined(pjob);
	if (i == 1) {
		script_out = open_std_file(pjob, StdOut, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
		script_err = dup(script_out);
	} else if (i == -1) {
		script_err = open_std_file(pjob, StdErr, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
		script_out = dup(script_err);
	} else {
		script_out = open_std_file(pjob, StdOut, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
		script_err = open_std_file(pjob, StdErr, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
	}

	if ((script_out < 0 || script_err < 0)) {
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_NOTICE,
			pjob->ji_qs.ji_jobid,
			"Unable to open standard output/error");
		return -1;
	}

	return 0;
}

/** @brief
 *      get_index_and_parent - from the job if of a subjob, return the parent array
 *      job jobid and the index for this subjob. The two returned strings are
 *      in static buffers and must be copied before this is called again.
 *
 * @param[in] jobid - job id
 * @param[out] pparent - parent array job
 * @param[out] pindex - index for subjob
 *
 * @return      Void
 *
 */
void
get_index_and_parent(char *jobid, char **pparent, char **pindex)
{
	char *pd;
	char *pi;
	char *ps;
	static char  parent[PBS_MAXSVRJOBID+1];
	static char  index[20];

	ps = jobid;
	pd = parent;
	pi = index;
	while (*ps != '[')	/* copy first part of job id */
		*pd++ = *ps++;
	*pd++ = *ps++;		/* copy in '[' */
	while (*ps != ']')	/* copy index  */
		*pi++ = *ps++;
	*pi = '\0';
	while (*ps)
		*pd++ = *ps++;
	*pd = '\0';
	*pparent = parent;
	*pindex  = index;
}

#ifdef WIN32
/**
 * @brief
 *      connect to the qsub that submitted this interactive job
 *
 * @param hostname[in] - hostname of the submission host where qsub is running.
 * @param port[in] - port number on which qsub is accepting connection.
 *
 * @return int
 * @retval >=0 the socket obtained
 * @retval  -1 PBS_NET_RC_FATAL
 * @retval  -2 PBS_NET_RC_RETRY
 */
int
conn_qsub(char *hostname, long port)
{
	pbs_net_t hostaddr;

	if ((hostname == NULL) || ((hostaddr = get_hostaddr(hostname)) == (pbs_net_t)0))
		return (PBS_NET_RC_FATAL);

	/* Yes, the qsub is listening, but for authentication
	 * purposes mom wants authenticate as a server - not as
	 * a client
	 */

	return (client_to_svr(hostaddr, (unsigned int)port, 0x0 | B_SVR));
}
#endif

/**
 * @brief
 *	Regenerate the PBS_NODEFILE of a job based on internal 
 *	nodes-related data.
 * @param[in]	pjob	- the job whose PBS_NODEFILE is to be generated.
 * @param[out]	nodefile- buffer to hold the path to PBS_NODEFILE
 *			  that got regenerated.		 
 *			  NOTE: Ok for this to be NULL, which means
 *			  don't save nodefile path.
 *
 * @param[in] nodefile_sz - size of the 'nodefile' buffer.
 * @param[out] err_msg	- buffer to hold the error message if this
 *			 functions returns a failure.
 * @param[in]	err_msg_sz - size of the 'err_msg' buffer.
 *
 * @return int
 * @retval  0	success
 * @retval < 0	failure
 *
 */
int
generate_pbs_nodefile(job *pjob, char *nodefile, int nodefile_sz,
					char *err_msg, int err_msg_sz)
{
	
	FILE			*nhow;
	int	   		j, vnodenum;
	char			pbs_nodefile[MAXPATHLEN+1];

	if (pjob == NULL) {
		snprintf(err_msg, err_msg_sz, "bad pjob param");
		return (-1);
	}

	if ((err_msg != NULL) && (err_msg_sz > 0)) {
		err_msg[0] = '\0';
	}
	snprintf(pbs_nodefile, sizeof(pbs_nodefile)-1, "%s/auxiliary/%s",
		pbs_conf.pbs_home_path, pjob->ji_qs.ji_jobid);

	/* In Windows, we'll create the nodes file in text mode to allow */
	/* applications like MPI to treat it as a native Windows file    */
	/* with terminating linefeed-carriage return characters.         */
	/*                                                               */
	/* This change is needed for proper parsing of nodes file by     */
	/* applications like  MPI. */
	if ((nhow = fopen(pbs_nodefile, "wt")) == NULL) {
		if ((err_msg != NULL) && (err_msg_sz > 0)) {
			snprintf(err_msg, err_msg_sz,
					"cannot open %s", pbs_nodefile);
		}
		return (-1);
	}

	/* write each node name out once per vnod and entry */
	vnodenum = pjob->ji_numvnod;
	for (j = 0; j < vnodenum; j++) {
		if (pjob->ji_vnods[j].vn_hname == NULL) {
			size_t len;
			char  *pdot;

			/* we want to write just the short name of the host */
			if ((pdot = strchr(pjob->ji_vnods[j].vn_host->hn_host, '.')) != NULL)
				len = (size_t)(pdot - pjob->ji_vnods[j].vn_host->hn_host);
			else
				len = strlen(pjob->ji_vnods[j].vn_host->hn_host);
			fprintf(nhow, "%.*s\n", (int)len,
				pjob->ji_vnods[j].vn_host->hn_host);
		} else
			fprintf(nhow, "%s\n", pjob->ji_vnods[j].vn_hname);
	}
	fclose(nhow);


	secure_file2(pbs_nodefile,
		"Administrators", READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED,
		"\\Everyone", READS_MASK | READ_CONTROL);


	if ((nodefile != NULL) && (nodefile_sz > 0)) { 
		strncpy(nodefile, pbs_nodefile, nodefile_sz);
		nodefile[nodefile_sz-1] = '\0';
	}

	return (0);
}

/**
 *
 * @brief
 *	Used by MOM superior to start the cmd process for 'pjob'.
 *
 * @param[in]	pjob - pointer to job whose cmd process is being started.
 *
 **/
void
finish_exec(job *pjob)
{
	char			buf[MAXPATHLEN+2] = {'\0'};
	int			i, j, vnodenum;
	int			is_interactive_job = 0;
	int			is_gui_job = 0;
	int			launch_shell = 0;
	int			numthreads;
	attribute		*pattr = NULL;
	attribute		*pattri = NULL;
	attribute		*pattrx = NULL;
	char			*shell = NULL; 
	char			*env_block = NULL;
	int			rc = 0;
	int                     rc_demux = 0;
	task			*ptask = NULL;
	struct	array_strings	*vstrs = NULL;
	FILE			*nhow = NULL;
	char			cmdline[PBS_CMDLINE_LENGTH] = {'\0'};
	char			cmdline_demux[PBS_CMDLINE_LENGTH] = {'\0'};
	struct	passwd		*pwdp = NULL;
	HANDLE			hjob = INVALID_HANDLE_VALUE;
	char                    *phost = NULL;
	int                     qsub_sock = -1;
	int                     old_qsub_sock = -1;
	STARTUPINFO		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	PROCESS_INFORMATION	pi_demux = { 0 };
	int		        flags = CREATE_SUSPENDED|
					CREATE_DEFAULT_ERROR_MODE|
					CREATE_NEW_CONSOLE|
					CREATE_NEW_PROCESS_GROUP;
	char			script_prefix[MAXPATHLEN+2] = {'\0'};
	char			*pbs_jobdir = NULL; /* staging and execution directory of this job */
	TCHAR			envbuf[ENV_BUFSIZE] = {'\0'};
	char			*arg_list = NULL;
	HANDLE                  hToken = INVALID_HANDLE_VALUE;
	HANDLE                  hLogin = INVALID_HANDLE_VALUE;
	int			hook_errcode = 0;
	char			hook_msg[HOOK_MSG_SIZE] = {'\0'};
	int                     is_MS = 0;/* Is this Mother Superior? */
	hook			*last_phook = NULL;
	unsigned int		hook_fail_action = 0;
	mom_hook_input_t	hook_input;
	mom_hook_output_t	hook_output;
	pbs_list_head		argv_list;
	char			*progname = NULL;
	char			*progname_out = NULL;
	char			**argv_in = NULL;
	char			**argv_out = NULL;
	char			*argv_str = NULL;
	char			**env = NULL;
	char			*env_str = NULL;
	SECURITY_ATTRIBUTES     sa;
	HANDLE                  hReadPipe_dummy = INVALID_HANDLE_VALUE;	/* dummy pipe read handle */
	HANDLE                  hWritePipe_dummy = INVALID_HANDLE_VALUE; /* dummy pipe write handle */
	char			cmd_shell[MAX_PATH + 1] = {'\0'};


	script_in = script_out = script_err = -1;
	is_MS = pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE;

	/*
	 * If the "user" can be determined, do so.
	 * we do this now to save a few things in the job structure
	 */
	if ((pwdp = check_pwd(pjob)) == NULL) {
		log_event(PBSEVENT_JOB | PBSEVENT_SECURITY, PBS_EVENTCLASS_JOB,
			LOG_ERR, pjob->ji_qs.ji_jobid, log_buffer);
		pjob->ji_qs.ji_stime = time_now; /* for walltime */
		exec_bail(pjob, JOB_EXEC_FAILUID, NULL);
		return;
	}

	/*
	 * if certain resource limits require that the job usage be
	 * polled or it is a multinode job, we link the job to mom_polljobs.
	 *
	 * NOTE: we overload the job field ji_jobque for this as it
	 * is not used otherwise by MOM
	 */

	if (pjob->ji_numnodes > 1 || mom_do_poll(pjob))
		if (is_linked(&mom_polljobs, &pjob->ji_jobque) == 0)
			append_link(&mom_polljobs, &pjob->ji_jobque, pjob);

	/* Is the job to be periodic checkpointed */

	pjob->ji_chkpttype = PBS_CHECKPOINT_NONE;
	pattr = &pjob->ji_wattr[(int)JOB_ATR_chkpnt];
	if (pattr->at_flags & ATR_VFLAG_SET) {
		if ((*pattr->at_val.at_str == 'c') &&
			(*(pattr->at_val.at_str+1) == '=')) {
			/* has cpu checkpoint time in minutes, convert to seconds */
			pjob->ji_chkpttype = PBS_CHECKPOINT_CPUT;
			pjob->ji_chkpttime = atoi(pattr->at_val.at_str+2) * 60;
		} else if ((*pattr->at_val.at_str == 'w') &&
			(*(pattr->at_val.at_str+1) == '=')) {
			/* has checkpoint walltime in minutes, convert to seconds */
			pjob->ji_chkpttype = PBS_CHECKPOINT_WALLT;
			pjob->ji_chkpttime = atoi(pattr->at_val.at_str+2) * 60;
		}
		pjob->ji_chkptnext = pjob->ji_chkpttime;
	}

	/* If job has been checkpointed, restart from the checkpoint image */

	if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHKPT) ||
		(pjob->ji_qs.ji_svrflags & JOB_SVFLG_ChkptMig)) {
		if ((i = local_restart(pjob, NULL)) != 0) {
			post_restart(pjob, i);
			exec_bail(pjob, (i == PBSE_CKPBSY) ?
				JOB_EXEC_RETRY : JOB_EXEC_FAIL2, NULL);
		}
		return;
	}

	pattri = &pjob->ji_wattr[(int)JOB_ATR_interactive];
	if ((pattri->at_flags & ATR_VFLAG_SET) &&
		(pattri->at_val.at_long != 0)) {
		is_interactive_job = 1;
	}
	/* Check if it is a GUI job */
	pattrx = &pjob->ji_wattr[(int)JOB_ATR_GUI];
	if ((pattrx->at_flags & ATR_VFLAG_SET) &&
		(pattrx->at_val.at_long != 0)) {
		is_gui_job = 1;
	}

	if ((ptask = momtask_create(pjob)) == NULL) {
		sprintf(log_buffer, "Task creation failed");
		exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
		return;
	}

	/* if passing script itself as input to shell */

	(void)strcpy(buf, path_jobs);
	if (*pjob->ji_qs.ji_fileprefix != '\0') {
		(void)strcat(buf, pjob->ji_qs.ji_fileprefix);
		(void)strcpy(script_prefix, pjob->ji_qs.ji_fileprefix);
	} else {
		(void)strcat(buf, pjob->ji_qs.ji_jobid);
		(void)strcpy(script_prefix, pjob->ji_qs.ji_jobid);
	}
	(void)strcat(buf, JOB_SCRIPT_SUFFIX);

	/* Add TMPDIR to environment */
	j = mktmpdir(pjob->ji_qs.ji_jobid, pjob->ji_user->pw_name);
	if (j != 0) {
		log_err(errno, __func__, "cannot create TMPDIR");
		exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
		return;
	}

	/* wait until after gaining info about the user */
	pbs_jobdir = jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir);

	/* set PBS_JOBDIR */
	if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
		(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
		/* Add PBS_JOBDIR if it doesn't already exist */
		j = mkjobdir(pjob->ji_qs.ji_jobid,
			pbs_jobdir,
			(pjob->ji_user != NULL) ? pjob->ji_user->pw_name : NULL, (pjob->ji_user != NULL) ? pjob->ji_user->pw_userlogin : INVALID_HANDLE_VALUE);
		if (j != 0) {
			sprintf(log_buffer, "unable to create the job directory %s", pbs_jobdir);
			log_err(errno, __func__, log_buffer);
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			(void)revert_impersonated_user();
			return;
		}
	}

	/* Later on, the following needs to be replaced by set_credential() */
	if (pjob->ji_user->pw_userlogin != INVALID_HANDLE_VALUE) {
		if (!impersonate_user(pjob->ji_user->pw_userlogin)) {
			sprintf(log_buffer,
				"failed to ImpersonateLoggedOnUser on %s", mom_host);
			(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment],
				ATTR_comment, NULL, log_buffer);
			exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, log_buffer);
			return;
		}
	}else{
		sprintf(log_buffer,
			"failed to ImpersonateLoggedOnUser on %s", mom_host);
		(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment],
			ATTR_comment, NULL, log_buffer);
		exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, log_buffer);
		return;
	}

	/*
	 * Create User's Home directory and change working directory to it.
	 * If in "sandbox=private" mode, it is preferable to create User's HOME,
	 * but it is Ok if we can't since job script runs in PBS_JOBDIR
	 */


	CreateDirectory(pjob->ji_grpcache->gc_homedir, 0);
	if (chdir(pjob->ji_grpcache->gc_homedir) == -1) {
		set_homedir_to_local_default(pjob, NULL);
		CreateDirectory(pjob->ji_grpcache->gc_homedir, 0);
		if (chdir(pjob->ji_grpcache->gc_homedir) == -1) {
			sprintf(log_buffer,
				"Could not chdir to Home directory=%s",
				pjob->ji_grpcache->gc_homedir);
			/*
			 * user Home is required if "qsub -k[oe]"
			 * and not sandbox=private i.e. job executed in user Home
			 */
			if (((pjob->ji_wattr[(int)JOB_ATR_keep].at_flags & ATR_VFLAG_SET) &&
				((strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, 'o')) ||
				(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, 'e')))) &&
				!((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
				(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0))) {
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				(void)revert_impersonated_user();
				return;
			} else if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
				(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
				/* "sandbox=PRIVATE" mode is active, so job can be started
				 * in PBS_JOBDIR instead of user Home
				 */
				if ((!pbs_jobdir) || (chdir(pbs_jobdir) == -1)) {
					log_event(PBSEVENT_JOB | PBSEVENT_SECURITY, PBS_EVENTCLASS_JOB,
						LOG_ERR, pjob->ji_qs.ji_jobid,
						"sandbox=PRIVATE mode: Could not chdir to job PBS_JOBDIR directory\n");
					exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
					(void)revert_impersonated_user();
					return;
				}
				/* an else case for O_WORKDIR should be added here */
			} else {
				/* nothing special specified, so job must be started in user Home  */
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				(void)revert_impersonated_user();
				return;
			}
		}
	}
	if (is_interactive_job == 1) {
		/*************************************************************************/
		/*              We have an "interactive" job, connect the standard       */
		/*              streams to a socket connected to qsub.                   */
		/*************************************************************************/
		/* Set environment to reflect interactive */
		bld_wenv_variables("PBS_ENVIRONMENT", "PBS_INTERACTIVE");
		/* get host where qsub resides */
		phost = arst_string("PBS_O_HOST",
			&pjob->ji_wattr[(int)JOB_ATR_variables]);
		if ((phost == (char *)0) || ((phost = strchr(phost, (int)'=')) == (char *)0)) {
			log_joberr(-1, __func__, "PBS_O_HOST not set",
				pjob->ji_qs.ji_jobid);
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			(void)revert_impersonated_user();
			return;
		}
		qsub_sock = conn_qsub(phost+1, pattri->at_val.at_long);
		if (qsub_sock < 0) {
			sprintf(log_buffer, "cannot open qsub sock for %s",
				pjob->ji_qs.ji_jobid);
			log_err(errno, __func__ , log_buffer);
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			(void)revert_impersonated_user();
			return;
		}
		/* send job id as validation to qsub */

		if (send(qsub_sock, pjob->ji_qs.ji_jobid, PBS_MAXSVRJOBID+1, 0) !=
			PBS_MAXSVRJOBID+1) {
			log_err(errno, __func__ , "cannot write jobid");
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			(void)revert_impersonated_user();
			return;
		}
		/* make sure qsub gets EOF */
		shutdown(qsub_sock, 2);
	}
	else {
		if (!(pjob->ji_wattr[(int)JOB_ATR_executable].at_flags & ATR_VFLAG_SET)) {
			script_in = open(buf, O_RDONLY, 0);
			if (script_in < 0) {
				log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
					pjob->ji_qs.ji_jobid,
					"Unable to open script");
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				(void)revert_impersonated_user();
				return;
			}
		}
		/* for non-interactive batch jobs, open std out and error */
		rc = open_std_out_err(pjob);
		if (rc == -1) {
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			return;
		}
	}
	/* Set shell if it is a batch job or an interactive GUI job */
	/* This is needed for job script or application support */
	if(is_interactive_job == 0 || is_gui_job == 1) {
		/*
		 ** find which shell to use, one specified or the login shell
		 */
		shell = set_shell(pjob, NULL);	/* in the machine dependent section */
	}
	(void)revert_impersonated_user();
	/*
	 ** set up the Environmental Variables to be given to the job
	 */
	vstrs = pjob->ji_wattr[(int)JOB_ATR_variables].at_val.at_arst;

	/*  First variables from the local environment */

	for (j = 0; j < num_var_env; ++j)
		bld_wenv_variables(environ[j], (char *)0);

	/* Second, the variables passed with the job.  They may */
	/* be overwritten with new correct values for this job	*/

	for (j = 0; j < vstrs->as_usedptr; ++j)
		bld_wenv_variables(vstrs->as_string[j], (char *)0);

	/*
	 ** If environment variable, ComSpec is already not setup, then
	 ** setup ComSpec by fetching it's value from System.
	 */

	if ((i = find_wenv_slot("ComSpec=")) < 0) {
		if ((ExpandEnvironmentStrings("%ComSpec%",
			envbuf, ENV_BUFSIZE) <= ENV_BUFSIZE) &&
			strncmp("%ComSpec%", envbuf, 9))
			bld_wenv_variables("ComSpec", envbuf);
	}

	/*
	 ** If environment variable, PATH is already not setup, then
	 ** setup the PATH by fetching it's value from user's environment.
	 */

	if ((i = find_wenv_slot("PATH=")) < 0) {
		if (pwdp->pw_userlogin == INVALID_HANDLE_VALUE) {
			HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
			/* Obtain access token for current process...*/

			if (OpenProcessToken(hProcess, MAXIMUM_ALLOWED, &hToken)) {
				if (DuplicateTokenEx(
					hToken,
					MAXIMUM_ALLOWED,
					NULL, SecurityImpersonation,
					TokenPrimary,
					&hLogin)) {
					/* get the size of the memory buffer needed for the SID */
					if ((ExpandEnvironmentStringsForUser(hLogin, "%PATH%",
						envbuf, ENV_BUFSIZE) != 0) && strncmp("%PATH%", envbuf, 6))
						bld_wenv_variables("PATH", envbuf);
				}
			}

			if (hLogin != INVALID_HANDLE_VALUE && hLogin != NULL)
				CloseHandle(hLogin);
			if (hToken != INVALID_HANDLE_VALUE && hToken != NULL)
				CloseHandle(hToken);
			if (hProcess != NULL)
				CloseHandle(hProcess); /* Don't forget to close the handle */
		}else {
			/* get the size of the memory buffer needed for the SID */
			if ((ExpandEnvironmentStringsForUser(pwdp->pw_userlogin , "%PATH%",
				envbuf, ENV_BUFSIZE) != 0) && strncmp("%PATH%", envbuf, 6))
				bld_wenv_variables("PATH", envbuf);
		}
	}

	/* .. Next the critical variables: home, path, logname, ... */
	/* these may replace some passed in with the job	    */

	/* HOME */
	bld_wenv_variables(variables_else[0],
		pjob->ji_grpcache->gc_homedir); /* HOME */

	/* LOGNAME */
	bld_wenv_variables(variables_else[1], pwdp->pw_name);

	/* PBS_JOBNAME */
	bld_wenv_variables(variables_else[2],
		pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str);

	/* PBS_JOBID */
	bld_wenv_variables(variables_else[3], pjob->ji_qs.ji_jobid);

	/* PBS_QUEUE */
	bld_wenv_variables(variables_else[4],
		pjob->ji_wattr[(int)JOB_ATR_in_queue].at_val.at_str);

	/* SHELL */
	if (is_interactive_job == 0)
		bld_wenv_variables(variables_else[5], shell);

	/* USER, for compatability */
	bld_wenv_variables(variables_else[6], pwdp->pw_name);

	/* PBS_JOBCOOKIE */
	bld_wenv_variables(variables_else[7],
		pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str);

	/* PBS_NODENUM */
	sprintf(buf, "%d", pjob->ji_nodeid);
	bld_wenv_variables(variables_else[8], buf);

	/* PBS_TASKNUM */
	sprintf(buf, "%u", ptask->ti_qs.ti_task);
	bld_wenv_variables(variables_else[9], buf);

	/* PBS_MOMPORT */
	sprintf(buf, "%d", pbs_rm_port);
	bld_wenv_variables(variables_else[10], buf);

	/* OMP_NUM_THREADS and NCPUS eq to number of cpus */

	numthreads = pjob->ji_vnods[0].vn_threads;
	sprintf(buf, "%d", numthreads);
	bld_wenv_variables(variables_else[12], buf);
	bld_wenv_variables("NCPUS", buf);

	/* PBS_NODEFILE */
	if (generate_pbs_nodefile(pjob, buf, sizeof(buf)-1, log_buffer,
						LOG_BUF_SIZE-1) == 0) {
		bld_wenv_variables(variables_else[11], buf);
	} else {
		log_err(errno, __func__, log_buffer);
		exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
	}
	umask(077);

	/* PBS_ACCOUNT */
	if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET)
		bld_wenv_variables(variables_else[13],
			pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str);

	/* If an Sub job of an Array job, put in the index */

	if (strchr(pjob->ji_qs.ji_jobid, (int)'[') != NULL) {
		char *pparent;
		char *pindex;

		get_index_and_parent(pjob->ji_qs.ji_jobid, &pparent, &pindex);
		bld_wenv_variables(variables_else[14], pindex);
		bld_wenv_variables(variables_else[15], pparent);
	}

	/* set PBS_JOBDIR */
	if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
		(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
		bld_wenv_variables("PBS_JOBDIR", pbs_jobdir);
	} else {
		bld_wenv_variables("PBS_JOBDIR", pjob->ji_grpcache->gc_homedir);
	}

	/* USERPROFILE */
	bld_wenv_variables(variables_else[16],
		default_local_homedir(pwdp->pw_name,
		pwdp->pw_userlogin, 1));

	/* USERNAME */
	bld_wenv_variables(variables_else[17], pwdp->pw_name);

	/*************************************************************************/
	/*		We have a "normal" batch job, connect the standard	 */
	/*		streams to files					 */
	/*************************************************************************/

	/* set Environment to reflect batch */
	if (is_interactive_job == 0) {
		bld_wenv_variables("PBS_ENVIRONMENT", "PBS_BATCH");
		bld_wenv_variables("ENVIRONMENT", "BATCH");
	}
	env_block = make_envp();

	/* run prolog */

	mom_hook_input_init(&hook_input);
	hook_input.pjob = pjob;

	mom_hook_output_init(&hook_output);
	hook_output.reject_errcode = &hook_errcode;
	hook_output.last_phook = &last_phook;
	hook_output.fail_action = &hook_fail_action;

	switch (mom_process_hooks(HOOK_EVENT_EXECJOB_PROLOGUE,
			PBS_MOM_SERVICE_NAME,
			mom_host, &hook_input, &hook_output,
			hook_msg, sizeof(hook_msg), 1)) {

		case 0:	/* explicit reject */
			if (hook_errcode == PBSE_HOOK_REJECT_DELETEJOB) {
				exec_bail(pjob, JOB_EXEC_FAILHOOK_DELETE, NULL);
			} else { /* rerun is the default */
				exec_bail(pjob, JOB_EXEC_FAILHOOK_RERUN, NULL);
			}
			return;
		case 1:   /* explicit accept */
			break;
		case 2:
			/* no hook script executed - run old style prologue */
			if ((j = run_pelog(PE_PROLOGUE,
				path_prolog, pjob, PE_IO_TYPE_ASIS)) == 1) {
				/* abort job */
				(void)fprintf(stderr,
					"Could not run prolog: %s\n", log_buffer);
				exec_bail(pjob, JOB_EXEC_FAIL2, NULL);
				return;
			} else if (j != 0) {
				/* requeue job */
				exec_bail(pjob, JOB_EXEC_RETRY, NULL);
				return;
			}
			break;
		default:
			log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK,
				LOG_INFO, "",
				"prologue hook event: accept req by default");
	}


	/*
	 **	Create the job and set the limits.
	 */
	hjob = CreateJobObject(NULL, pjob->ji_qs.ji_jobid);
	if (hjob == NULL) {
		exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
		if (env_block)
			free(env_block);
		return;
	}
	pjob->ji_hJob = hjob;

	/*************************************************************************/
	/*	Set resource limits				 		 */
	/*	Both normal batch and interactive job come through here 	 */
	/*************************************************************************/

	if ((i = mom_set_limits(pjob, SET_LIMIT_SET)) != PBSE_NONE) {
		(void)sprintf(log_buffer, "Unable to set limits, err=%d", i);
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, log_buffer);
		if (i == PBSE_RESCUNAV) {	/* resource temp unavailable */
			if (is_interactive_job == 1)
				j = JOB_EXEC_FAIL2;
			else
				j = JOB_EXEC_RETRY;
		}
		else
			j = JOB_EXEC_FAIL2;
		exec_bail(pjob, j, NULL);
		if (env_block)
			free(env_block);
		return;
	}

	/*
	 **	Create new process using the batch login handle.
	 */
	si.cb = sizeof(si);
	if (is_interactive_job == 0 || is_gui_job) { /* batch job or a GUI job can have script associated */
		/*
		 * To hide the black screen popping up while job is running
		 * in Personal Mode.
		 */
		si.lpDesktop = PBS_DESKTOP_NAME;
		si.dwFlags = STARTF_USESTDHANDLES;
				
			
		if (script_in != -1)
			si.hStdInput = (HANDLE)_get_osfhandle(script_in);
		else {
			/* 
			 * A blocking process will not block on input unless it has a valid input handle.
			 * This results in many issues like a blocking command gets blank as input
			 * and in case of many commands such inputs are constantly rejected and 
			 * the commands keep running infinitely waiting for correct input,
			 * resulting in high CPU consupmtion and very very large error files that
			 * may result in disk full conditions.
			 * Create a dummpy pipe and use it's handle as stdin of child process. 
			 * This is required to block on process that need user input (wrongly)
			 * even when invoked for read only.
			 */
			sa.nLength = sizeof(sa);
			sa.lpSecurityDescriptor = NULL;
			sa.bInheritHandle = TRUE;
			if (CreatePipe(&hReadPipe_dummy, &hWritePipe_dummy, &sa, 0) == 0) {
				log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_ERR,
					pjob->ji_qs.ji_jobid, "Creation of pipe failed. No valid input handle for the job.");
				return;
			}
			si.hStdInput = hReadPipe_dummy;
		}
		if (script_out != -1)
			si.hStdOutput = (HANDLE)_get_osfhandle(script_out);
		if (script_err != -1)
			si.hStdError = (HANDLE)_get_osfhandle(script_err);
		/* turn off echoing if cmd.exe */
		if (strstr(shell, "cmd") ||
			strstr(shell, "CMD") ||
			strstr(shell, "Cmd")) {
			char script_path[MAXPATHLEN+2] = {0};
			char script_bat[MAXPATHLEN+2] = {0};

			/* use of goto labels inside job script */
			/* requires it to be passed on the command line */
			/* as a ".bat" file */
			sprintf(script_path, "%s%s%s", path_jobs, script_prefix,
				JOB_SCRIPT_SUFFIX);
			sprintf(script_bat, "%s%s.BAT", path_jobs, script_prefix);
			forward2back_slash(script_path);
			forward2back_slash(script_bat);
			if (pjob->ji_wattr[(int)JOB_ATR_executable].at_flags  &
				ATR_VFLAG_SET) {
				/*
				 * User has specified executable and its arguments
				 * as command-line options to qsub. So call
				 * 'decode_xml_arg_list_str' function to get
				 * decoded XML string.
				 */
				rc = decode_xml_arg_list_str(
					pjob->ji_wattr[(int)JOB_ATR_Arglist].at_val.at_str,
					&arg_list);
				if (rc) {
					exec_bail(pjob, JOB_EXEC_FAIL2, NULL);
					return;
				}
				if(arg_list != NULL) {
					sprintf(cmdline, "%s %s",
						pjob->ji_wattr[(int)JOB_ATR_executable].at_val.at_str,
						arg_list);
				}
				else {
					sprintf(cmdline, "%s",
						pjob->ji_wattr[(int)JOB_ATR_executable].at_val.at_str);
				}
			} else if (CopyFile(script_path, script_bat, FALSE) != 0) {
				secure_file2(script_bat,
					pwdp->pw_name,
					READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED,
					"Administrators",
					READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED);
				
				sprintf(cmdline, "%s /Q /C \"%s\"", shell, script_bat);
				log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
					pjob->ji_qs.ji_jobid, cmdline);
			} else {
				sprintf(cmdline, "%s /Q", shell);
				/* Need to launch a shell*/
				launch_shell = 1;
			}
		} else {
			strcpy(cmdline, shell);
			/* Need to launch a shell*/
			launch_shell = 1;
		}
		/* If we fail to get cmd shell(unlikely), use "cmd.exe" as shell */
		if (0 != get_cmd_shell(cmd_shell, sizeof(cmd_shell)))
			(void)snprintf(cmd_shell, sizeof(cmd_shell) - 1, "cmd.exe");
		snprintf(cmdline_demux, _countof(cmdline_demux) -1,
			"%s /c %s/sbin/pbs_demux.exe %s %d", cmd_shell,
			pbs_conf.pbs_exec_path, pjob->ji_qs.ji_jobid, pjob->ji_numnodes);
	}
	if(is_interactive_job) { /* Interactive job */
		/* Pass commandline to mom_shell to launch a GUI application or job script */
		/* For an interactive job cmdline is non-NULL for GUI jobs only as non-GUI interactive jobs do not support application or job script */
		/* A GUI job needs username to launch application in user session */
		if(cmdline[0] != '\0' && (launch_shell == 0)) {
			char	cmdline_full[PBS_CMDLINE_LENGTH] = {'\0'};
			snprintf(cmdline_full, _countof(cmdline_full) -1,
				"%s/sbin/mom_shell.exe %s %d %d %s \"%s\"",
				pbs_conf.pbs_exec_path, pjob->ji_qs.ji_jobid, pjob->ji_numnodes, is_gui_job, pwdp->pw_name, cmdline);
			strncpy(cmdline, cmdline_full, _countof(cmdline_full) -1);
		}
		else {
			/* A GUI job can be launched using interactive shell too */
			/* A GUI job needs username to launch application in user session */
			if(is_gui_job == 1) {
				snprintf(cmdline, _countof(cmdline) -1,
				"%s/sbin/mom_shell.exe %s %d %d %s",
				pbs_conf.pbs_exec_path, pjob->ji_qs.ji_jobid, pjob->ji_numnodes, is_gui_job, pwdp->pw_name);
			}
			/* A non-GUI job doesn't needs username */
			else {
				snprintf(cmdline, _countof(cmdline) -1,
				"%s/sbin/mom_shell.exe %s %d %d",
				pbs_conf.pbs_exec_path, pjob->ji_qs.ji_jobid, pjob->ji_numnodes, is_gui_job);
			}
		}
	}

	if (pwdp->pw_userlogin != INVALID_HANDLE_VALUE) { /* ENTERPRISE  MODE */

		argv_in = str_to_str_array(cmdline, " ");
		if ((argv_in == NULL) || (argv_in[0] == NULL)) {

			if (argv_in != NULL) {
				free_str_array(argv_in);
			}
			exec_bail(pjob, JOB_EXEC_FAIL2, "bad commandline");
			return;
		}

		progname = strdup(argv_in[0]);
		if (progname == NULL) {
			free_str_array(argv_in);
			exec_bail(pjob, JOB_EXEC_FAIL2, "failed to strdup progname");
			return;
		}

		env = env_array; /* pass current environment array */

		mom_hook_input_init(&hook_input);
		hook_input.pjob = pjob;
		hook_input.progname = progname;
		hook_input.argv = argv_in;
		hook_input.env = env;

		mom_hook_output_init(&hook_output);
		hook_output.reject_errcode = &hook_errcode;

		hook_output.last_phook = &last_phook;
		hook_output.fail_action = &hook_fail_action;
		hook_output.progname = &progname_out;
		CLEAR_HEAD(argv_list);
		hook_output.argv = &argv_list;

		switch (mom_process_hooks(HOOK_EVENT_EXECJOB_LAUNCH,
				PBS_MOM_SERVICE_NAME,
				mom_host, &hook_input, &hook_output,
				hook_msg, sizeof(hook_msg), 0)) {

			case 0:	/* explicit reject */
				free_str_array(argv_in);
				free(progname_out);
				free_attrlist(&argv_list);
				free(env_str);


				exec_bail(pjob, JOB_EXEC_FAIL2, NULL);
				return;
			case 1:   /* explicit accept */
				if (progname_out == NULL) {
					free_str_array(argv_in);
					free_attrlist(&argv_list);
					free(env_str);

					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL progname!");
					return;
				}

				argv_out = svrattrl_to_str_array(&argv_list);
				if (argv_out == NULL) {
					free_str_array(argv_in);
					free(progname_out);
					free_attrlist(&argv_list);
					free_str_array(hook_output.env);

					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL argv!");
					return;
				}

				/* progname_out now becomes argv[0] */
				/* freeing argv_out[] will automatically */
				/* free progname_out */
				free(argv_out[0]);
				argv_out[0] = progname_out;
				argv_str = str_array_to_str(argv_out,
								" ");
				if (argv_str == NULL) {

					free_str_array(argv_in);
					free_attrlist(&argv_list);
					free_str_array(hook_output.env);
					free_str_array(argv_out);

					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL argv_str!");
					return;
				}


				strncpy(cmdline, argv_str, sizeof(cmdline)-1);
				log_event(PBSEVENT_JOB,
					PBS_EVENTCLASS_JOB, LOG_INFO,
					pjob->ji_qs.ji_jobid,
							cmdline);
				free(argv_str);
				free_str_array(argv_out);


				env = hook_output.env;
				if (env == NULL) {
					free_str_array(argv_in);
					free_attrlist(&argv_list);
					exec_bail(pjob, JOB_EXEC_FAIL2,
						  "execjob_launch hook NULL env!");
					return;
				}

				/* numenv is the total # of */
				/* slots in env_array including */
				/*  unused slots */
				/* curenv is the total # of used */
				/* slots */
				curenv = numenv;
				init_envp(); /* free up all entries */
				/* in env_array */
				free(env_block);/* since values from */
				/* previous env_array */

				env_array = env;
				curenv = 0;
				while(env_array[curenv] != NULL)
					curenv++;

				numenv = curenv;
				/* re-populate env_block */
				/* with entries from */
				/* new env_array */
				env_block = make_envp();

				break;
			case 2:	  /* no hook script executed - go ahead and accept event */
				break;
			default:
				log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK,
					LOG_INFO, "",
					"execjob_launch hook event: accept req by default");
		}

		free_str_array(argv_in);
		free_attrlist(&argv_list);
		free_str_array(hook_output.env);

		/*
		 * In case of Interactive job, we need not collect std output and error into files.
		 * For normal batch jobs, if it is a multinode job and since this is mother superior
		 * run the pbs_demux process and redirect the output and error into files.
		 * For multinode interactive jobs, pbs_demux is run inside job's mom_shell.
		 * In case of GUI job, CreateProcessAsUser() is not used since the mom_shell takes
		 * care of launching the job into user session.
		 */
		/* create job process in TMPDIR or in user's Home */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
				/* 
				 * User impersonation is necessary to launch a job 
				 * if PBS job directory is a network mapped drive
				 * accessible only under user session
				 */
				if ((impersonate_user(pwdp->pw_userlogin) == 0) && is_network_drive_path(pbs_jobdir)) {
					snprintf(log_buffer, sizeof(log_buffer) - 1, "warning: failed to impersonate user %s error=%d",
						pwdp->pw_name, GetLastError());
					log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB,
						LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
					exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
					return;
				}
				if(is_gui_job) {
					rc = CreateProcess( NULL, cmdline, NULL, NULL, TRUE, flags,
						env_block, pbs_jobdir, &si, &pi);
				} else {
					rc = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline,
						NULL, NULL, TRUE, flags,
						env_block, pbs_jobdir, &si, &pi);
				}
				if (!is_interactive_job && (pjob->ji_numnodes > 1)) {
					rc_demux = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline_demux,
						NULL, NULL, TRUE, flags,
						env_block, pbs_jobdir, &si, &pi_demux);
				}
		} else {
			/* 
			 * User impersonation is necessary to launch a job
			 * if user home directory is a network mapped drive
			 * accessible only under user session
			 */
			if ((impersonate_user(pwdp->pw_userlogin) == 0) && is_network_drive_path(pjob->ji_grpcache->gc_homedir)) {
				snprintf(log_buffer, sizeof(log_buffer) - 1, "warning: failed to impersonate user %s error=%d",
					pwdp->pw_name, GetLastError());
				log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_JOB,
					LOG_DEBUG, pjob->ji_qs.ji_jobid, log_buffer);
				exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
				return;
			}
			if(is_gui_job) {
				rc = CreateProcess(NULL, cmdline,
					NULL, NULL, TRUE, flags,
					env_block, pjob->ji_grpcache->gc_homedir, &si, &pi);
			} else {
				rc = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline,
					NULL, NULL, TRUE, flags,
					env_block, pjob->ji_grpcache->gc_homedir, &si, &pi);
			}
			if (!is_interactive_job && (pjob->ji_numnodes > 1)) {
				rc_demux = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline_demux,
					NULL, NULL, TRUE, flags,
					env_block, pjob->ji_grpcache->gc_homedir, &si, &pi_demux);
			}
		}
	} else if (strcmpi(pwdp->pw_name, getlogin()) == 0) { /* Personal Mode */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			rc = CreateProcess(NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pbs_jobdir, &si, &pi);
			if (!is_interactive_job && (pjob->ji_numnodes > 1))
				rc_demux = CreateProcess(NULL, cmdline_demux,
					NULL, NULL, TRUE, flags,
					env_block, pbs_jobdir, &si, &pi_demux);
		} else {
			rc = CreateProcess(NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pjob->ji_grpcache->gc_homedir, &si, &pi);
			if (!is_interactive_job && (pjob->ji_numnodes > 1))
				rc_demux = CreateProcess(NULL, cmdline_demux,
					NULL, NULL, TRUE, flags,
					env_block, pjob->ji_grpcache->gc_homedir, &si, &pi_demux);
		}
	} else {
		sprintf(log_buffer, "failed to ImpersonateLoggedOnUser on %s", mom_host);
		(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment], ATTR_comment, NULL, log_buffer);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
		exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
		(void)revert_impersonated_user();
		return;
	}
	(void)revert_impersonated_user();

	if (script_in != -1) {
		close(script_in);
		si.hStdInput = INVALID_HANDLE_VALUE;
		script_in = -1;
	}
	if (is_interactive_job == 0) { /* Batch job */
		if (script_out != -1) {
			close(script_out);
			si.hStdOutput = INVALID_HANDLE_VALUE;
			script_out = -1;
		}
		if (script_err != -1) {
			close(script_err);
			si.hStdError = INVALID_HANDLE_VALUE;
			script_err = -1;
		}
	}
	close_valid_handle(&(si.hStdInput));
	close_valid_handle(&(si.hStdOutput));
	close_valid_handle(&(si.hStdError));
	close_valid_handle(&(hWritePipe_dummy));
	
	/* restore MOM to its home */
	(void)chdir(mom_home);

	if (env_block)
		free(env_block);

	if (!rc) {
		sprintf(log_buffer, "CreateProcess(AsUser) error=%d",
			GetLastError());
		exec_bail(pjob, JOB_EXEC_FAIL1, log_buffer);
		return;
	}
	ptask->ti_hProc = pi.hProcess;
	ptask->ti_qs.ti_sid = pi.dwProcessId;

	/*
	 **	Get the job going.
	 */
	/* 
	 * An interactive GUI job would run mom_shell as LOCALSYSTEM account while
	 * the application itself is going to be run as the job submitting user.
	 * Thus you have two processes running in different user sessions.
	 * You can not assign processes running in different user sessions,
	 * to a job object. All processes should run in same user session.
	 * PBS already takes care of termination and accounting of processes
	 * that could not be attached to the job object.
	 */
	if(!is_gui_job) {
		rc = AssignProcessToJobObject(hjob, pi.hProcess);
		if (!rc) {
			snprintf(log_buffer, _countof(log_buffer) - 1, "AssignProcessToJobObject, error = %d", GetLastError());
			close_valid_handle(&(pi.hThread));
			if (!is_interactive_job)
				close_valid_handle(&(pi_demux.hThread));
			exec_bail(pjob, JOB_EXEC_FAIL1, log_buffer);
			return;
		}
	}	
	if (!is_interactive_job && (pjob->ji_numnodes > 1)) {
		rc = AssignProcessToJobObject(hjob, pi_demux.hProcess);
		if (!rc) {
			snprintf(log_buffer, _countof(log_buffer) - 1, "AssignProcessToJobObject, error = %d", GetLastError());
			close_valid_handle(&(pi.hThread));
			close_valid_handle(&(pi_demux.hThread));
			exec_bail(pjob, JOB_EXEC_FAIL1, log_buffer);
			return;
		}
	}

	/*
	 **	After the CreateJob
	 */
	ptask->ti_qs.ti_status = TI_STATE_RUNNING;
	strcpy(ptask->ti_qs.ti_parentjobid, pjob->ji_qs.ji_jobid);
	if (task_save(ptask) == -1) {
		sprintf(log_buffer, "Task save failed");
		close_valid_handle(&(pi.hThread));
		if (!is_interactive_job)
			close_valid_handle(&(pi_demux.hThread));
		exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
		return;
	}

	/* start of walltime shouldn't account for task_save() by PBS */
	pjob->ji_qs.ji_stime = time_now;

	rc = ResumeThread(pi.hThread);
	if (rc == -1) {
		sprintf(log_buffer, "ResumeThread");
		close_valid_handle(&(pi.hThread));
		if (!is_interactive_job)
			close_valid_handle(&(pi_demux.hThread));
		exec_bail(pjob, JOB_EXEC_FAIL1, log_buffer);
		return;
	}
	close_valid_handle(&(pi.hThread));
	if (!is_interactive_job && (pjob->ji_numnodes > 1)) {
		rc = ResumeThread(pi_demux.hThread);
		if (rc == -1) {
			sprintf(log_buffer, "ResumeThread");
			close_valid_handle(&(pi_demux.hThread));
			exec_bail(pjob, JOB_EXEC_FAIL1, log_buffer);
			return;
		}
	}
	if (!is_interactive_job && (pjob->ji_numnodes > 1))
		close_valid_handle(&(pi_demux.hThread));

	/* record the start time and session/process id		 */

	pjob->ji_wattr[(int)JOB_ATR_session_id].at_val.at_long
	= pi.dwProcessId;
	pjob->ji_wattr[(int)JOB_ATR_session_id].at_flags =
		ATR_VFLAG_SET | ATR_VFLAG_MODIFY;

	/* record job directory in job attribute */
	if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
		(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
		/* job is handled in PBS_JOBDIR */
		strcpy(buf, pbs_jobdir);
	} else {
		/* job is handled in user HOME */
		strcpy(buf, pjob->ji_grpcache->gc_homedir);
	}
	back2forward_slash(buf);
	decode_str(&pjob->ji_wattr[JOB_ATR_jobdir],
		ATTR_jobdir, NULL, buf);
	pjob->ji_wattr[(int)JOB_ATR_jobdir].at_flags =
		ATR_VFLAG_SET | ATR_VFLAG_MODIFY;

	pjob->ji_qs.ji_state = JOB_STATE_RUNNING;
	pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
	job_save(pjob, SAVEJOB_QUICK);

	if (mom_get_sample() == PBSE_NONE) {
		time_resc_updated = time_now;
		(void)mom_set_use(pjob);
	}
	update_ajob_status(pjob);
	next_sample_time = MIN_CHECK_POLL_TIME;
	sprintf(log_buffer, "Started, pid = %d", pi.dwProcessId);
	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
		pjob->ji_qs.ji_jobid, log_buffer);

	return;
}

/**
 * @brief
 * 	Start a process for a spawn request.  This will be different from
 * 	a job's initial shell task in that the environment will be specified
 * 	and no interactive code need be included.
 *
 * @param[in]	ptask - pointer to task
 * @param[in]	argv - arguments to the task process
 * @param[in]	envp - environment to be passed to the task process
 * @param[in]	nodemux - false if the task process needs demux, true otherwise

 * @return      int
 * @retval      PBSE_NONE (0) if success
 * @retval      PBSE_* on error.
 */
int
start_process(task *ptask, char **argv, char **envp, bool nodemux)
{
	job	                *pjob = ptask->ti_job;
	char	                buf[MAXPATHLEN+2] = {'\0'};
	char	                envbuf[ENV_BUFSIZE] = {'\0'};
	char	                cmdline[PBS_CMDLINE_LENGTH] = {'\0'};
	char                    shell[MAX_PATH + 1] = {'\0'};
	char	                *env_block = NULL;
	struct	passwd          *pwdp = NULL;
	int	                i, j;
	int	                rc;
	u_long	                ipaddr;
	HANDLE			hjob = INVALID_HANDLE_VALUE;
	STARTUPINFO		si = { 0 };
	PROCESS_INFORMATION	pi = { 0 };
	STARTUPINFO		si_demux = { 0 };
	PROCESS_INFORMATION	pi_demux = { 0 };
	int		        flags = CREATE_SUSPENDED
		|CREATE_DEFAULT_ERROR_MODE
	|CREATE_NEW_CONSOLE
	|CREATE_NEW_PROCESS_GROUP;
	SECURITY_ATTRIBUTES     sa = { sizeof(SECURITY_ATTRIBUTES),
		NULL, TRUE};
	struct	array_strings	*vstrs = NULL;
	char			*pbs_jobdir; /* staging and execution directory of this job */
	HANDLE                  hToken = INVALID_HANDLE_VALUE;
	HANDLE                  hLogin = INVALID_HANDLE_VALUE;

	int                     is_MS = 0;/* Is this mother superior? */
	int                     is_interactive_job = 0;/* Is the job interactive? */
	attribute               *pattri = NULL;
	int			hook_errcode = 0;
	char			hook_msg[HOOK_MSG_SIZE];
	hook			*last_phook = NULL;
	unsigned int		hook_fail_action = 0;
	mom_hook_input_t	hook_input;
	mom_hook_output_t	hook_output;
	pbs_list_head		argv_list;
	char			*progname = NULL;
	char			*progname_out = NULL;
	char			**argv_in = NULL;
	char			**argv_out = NULL;
	char			*argv_str = NULL;
	char			**env;
	char			*env_str = NULL;
	char			*p = NULL;
	char			cmd_shell[MAX_PATH + 1] = {'\0'};

	/* should not be impersonated user */
	(void)revert_impersonated_user();
	is_MS = pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE;
	pattri = &pjob->ji_wattr[(int)JOB_ATR_interactive];
	if ((pattri->at_flags & ATR_VFLAG_SET) && (pattri->at_val.at_long != 0)) {
		is_interactive_job = 1;
	}
	pbs_jobdir = jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir);
	script_in = script_out = script_err = -1;
	umask(077);

	if ((pwdp = check_pwd(pjob)) == NULL) {
		log_err(-1, __func__, log_buffer);
		return PBSE_SYSTEM;
	}

	/*
	 ** Get ipaddr to Mother Superior.
	 */
	if (is_MS)	/* I'm MS */
		ipaddr = htonl(localaddr);
	else {
		struct	sockaddr_in	*ap;

		/*
		 ** We always have a stream open to MS at node 0.
		 */
		i = pjob->ji_hosts[0].hn_stream;
		if ((ap = rpp_getaddr(i)) == NULL) {
			sprintf(log_buffer, "job %s has no stream to MS",
				pjob->ji_qs.ji_jobid);
			log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
			return PBSE_SYSTEM;
		}
		ipaddr = ap->sin_addr.s_addr;
	}

	/* Later on, the following needs to be replaced by set_credential. */
	if (pwdp->pw_userlogin != INVALID_HANDLE_VALUE) {
		if (!impersonate_user(pwdp->pw_userlogin)) {
			sprintf(log_buffer,
				"failed to ImpersonateLoggedOnUser on %s", mom_host);
			(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment],
				ATTR_comment, NULL, log_buffer);
			log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
			exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
			return PBSE_SYSTEM;
		}
	}else{
		sprintf(log_buffer,
			"failed to ImpersonateLoggedOnUser on %s", mom_host);
		(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment],
			ATTR_comment, NULL, log_buffer);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
		exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
		return PBSE_SYSTEM;
	}
	/* On Windows, do not open sockets for stdout and stderr */
#ifndef WIN32
	if (pjob->ji_numnodes > 1) {
		/*
		 ** Open sockets to demux proc for stdout and stderr.
		 */
		char	*cookie = pjob->ji_wattr[(int)JOB_ATR_Cookie].
			at_val.at_str;
		int		clen = strlen(cookie);

		script_out = open_demux(ipaddr, pjob->ji_stdout);
		script_err = open_demux(ipaddr, pjob->ji_stderr);
		if (script_out == -1 || script_err == -1) {
			proc_bail(ptask);
			if (user_impersonate) {
				RevertToSelf();
				user_impersonate = 0;
			}
			return PBSE_SYSTEM;
		}

		if (send(script_out, cookie, clen, 0) != clen) {
			proc_bail(ptask);
			if (user_impersonate) {
				RevertToSelf();
				user_impersonate = 0;
			}
			return PBSE_SYSTEM;
		}
		if (send(script_err, cookie, clen, 0) != clen) {
			proc_bail(ptask);
			if (user_impersonate) {
				RevertToSelf();
				user_impersonate = 0;
			}
			return PBSE_SYSTEM;
		}
	}
	else {
#endif
		/* Normal batch job, single node, task with nodemux, write straight to files
		 * For interactive job, do not write to files.
		 */
		if (!is_interactive_job && ((pjob->ji_numnodes == 1) || nodemux) && (open_std_out_err(pjob) == -1)) {
			proc_bail(ptask);
			(void)revert_impersonated_user();
			return PBSE_SYSTEM;
		}
#ifndef WIN32
	}
#endif

	(void)revert_impersonated_user();
#ifdef WIN32
	/*
	 * Find which shell to use, one specified or the login shell
	 * If we fail to get cmd shell(unlikely), use "cmd.exe" as shell
	 */
	if (0 != get_cmd_shell(shell, sizeof(shell)))
		(void)snprintf(shell, sizeof(shell) - 1, "cmd.exe");
	if ((pjob->ji_numnodes == 1) && !is_interactive_job) {
		(void)snprintf(cmdline, _countof(cmdline) - 1, "%s /c", shell);
		(void)strncat_s(cmdline, _countof(cmdline), " ",  _TRUNCATE);
		(void)strncat_s(cmdline, _countof(cmdline), argv[0],  _TRUNCATE);
#else
	strcpy(cmdline, argv[0]);
#endif
	for (i=1; argv[i]; i++) {
		strcat(cmdline, " ");
		strcat(cmdline, argv[i]);
	}
#ifdef WIN32
	}
#endif

	/*
	 * set up the Environmental Variables to be given to the job
	 */
	vstrs = pjob->ji_wattr[(int)JOB_ATR_variables].at_val.at_arst;
	
	/* First variables from the local environment */
	for (j = 0; j < num_var_env; ++j)
		bld_wenv_variables(environ[j], (char *)0);
	
	/* Next, the variables passed with the job.  They may   */
	/* be overwritten with new correct values for this job	*/
	
	for (j = 0; j < vstrs->as_usedptr; ++j)
		bld_wenv_variables(vstrs->as_string[j], (char *)0);
	
	/*
	 ** If environment variable, PATH is already not setup, then
	 ** setup the PATH by fetching it's value from user's environment.
	 */
	if ((i = find_wenv_slot("PATH=")) < 0) {
		if (pwdp->pw_userlogin == INVALID_HANDLE_VALUE) {
			HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId());
			/* Obtain access token for current process.*/
	
			if (OpenProcessToken(hProcess, MAXIMUM_ALLOWED, &hToken)) {
				if (DuplicateTokenEx(
					hToken,
					MAXIMUM_ALLOWED,
					NULL, SecurityImpersonation,
					TokenPrimary,
					&hLogin)) {
					/* get the size of the memory buffer needed for the SID */
					if ((ExpandEnvironmentStringsForUser(hLogin, "%PATH%",
						envbuf, ENV_BUFSIZE) != 0) && strncmp("%PATH%", envbuf, 6))
						bld_wenv_variables("PATH", envbuf);
				}
			}
	
			if (hLogin != INVALID_HANDLE_VALUE && hLogin != NULL)
				CloseHandle(hLogin);
			if (hToken != INVALID_HANDLE_VALUE && hToken != NULL)
				CloseHandle(hToken);
			if (hProcess != NULL)
				CloseHandle(hProcess); /* Don't forget to close the handle */
		}else {
			/* get the size of the memory buffer needed for the SID */
			if ((ExpandEnvironmentStringsForUser(pwdp->pw_userlogin , "%PATH%",
				envbuf, ENV_BUFSIZE) != 0) && strncmp("%PATH%", envbuf, 6))
				bld_wenv_variables("PATH", envbuf);
		}
	}
	
	/* HOME */
	bld_wenv_variables(variables_else[0], pjob->ji_grpcache->gc_homedir);
	
	/* PBS_JOBNAME */
	bld_wenv_variables(variables_else[2],
		pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str);
	
	/* PBS_JOBID */
	bld_wenv_variables(variables_else[3], pjob->ji_qs.ji_jobid);
	
	/* PBS_QUEUE */
	bld_wenv_variables(variables_else[4],
		pjob->ji_wattr[(int)JOB_ATR_in_queue].at_val.at_str);
	
	/* PBS_JOBCOOKIE */
	bld_wenv_variables(variables_else[7],
		pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str);
	
	/* PBS_NODENUM */
	sprintf(buf, "%d", pjob->ji_nodeid);
	bld_wenv_variables(variables_else[8], buf);
	
	/* PBS_TASKNUM */
	sprintf(buf, "%ld", (long)ptask->ti_qs.ti_task);
	bld_wenv_variables(variables_else[9], buf);
	
	/* PBS_MOMPORT */
	sprintf(buf, "%d", pbs_rm_port);
	bld_wenv_variables(variables_else[10], buf);
	
	/* OMP_NUM_THREADS and NCPUS eq to number of cpus */
	sprintf(buf, "%d", pjob->ji_vnods[ptask->ti_qs.ti_myvnode].vn_threads);
	bld_wenv_variables(variables_else[12], buf);
	bld_wenv_variables("NCPUS", buf);
	
	/* PBS_ACCOUNT */
	if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET)
		bld_wenv_variables(variables_else[13],
			pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str);
	
	/* Add TMPDIR to environment */
	j = mktmpdir(pjob->ji_qs.ji_jobid, pjob->ji_user->pw_name);
	if (j != 0) {
		log_err(errno, __func__, "cannot create TMPDIR");
		exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
		return PBSE_SYSTEM;
	}
	
	/* set PBS_JOBDIR */
	if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
		(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
		bld_wenv_variables("PBS_JOBDIR", pbs_jobdir);
	} else {
		bld_wenv_variables("PBS_JOBDIR", pjob->ji_grpcache->gc_homedir);
	}
	
	/* USERPROFILE */
	bld_wenv_variables(variables_else[16],
		default_local_homedir(pwdp->pw_name,
		pwdp->pw_userlogin, 1));
	
	/* USERNAME */
	bld_wenv_variables(variables_else[17], pwdp->pw_name);
	
	/* set Environment to reflect batch */
	bld_wenv_variables("PBS_ENVIRONMENT", "PBS_BATCH");
	bld_wenv_variables("ENVIRONMENT", "BATCH");
	
	for (i=0; envp[i]; i++)
		bld_wenv_variables(envp[i], NULL);
	
	/*
	 **	Might need to create a job and set the limits.
	 */
	if (pjob->ji_hJob == NULL) {
		hjob = CreateJobObject(NULL, pjob->ji_qs.ji_jobid);
		if (hjob == NULL) {
			exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
			return PBSE_SYSTEM;
		}
		pjob->ji_hJob = hjob;
		if ((i = mom_set_limits(pjob, SET_LIMIT_SET)) != PBSE_NONE) {
			(void)sprintf(log_buffer, "Unable to set limits, err=%d", i);
			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB,
				LOG_WARNING, pjob->ji_qs.ji_jobid, log_buffer);
			if (i == PBSE_RESCUNAV)		/* resource temp unavailable */
				j = JOB_EXEC_RETRY;
			else
				j = JOB_EXEC_FAIL2;
			exec_bail(pjob, j, NULL);
			return PBSE_SYSTEM;
		}
	}
	/*
	 ** Begin a new process for the fledgling task.
	 */
	env_block = make_envp();
	si.cb = sizeof(si);
	
	/*
	 * To hide the black screen popping up while job is running
	 * in Personal Mode.
	 */
	
	si.lpDesktop = PBS_DESKTOP_NAME;
	
	si.hStdInput = INVALID_HANDLE_VALUE;
	if ((is_interactive_job) || ((pjob->ji_numnodes > 1) && (!nodemux))) {	/* mom_open_demux mechanism available */
		si.hStdOutput = INVALID_HANDLE_VALUE;
		si.hStdError = INVALID_HANDLE_VALUE;
	} else { /* no mom_open_demux, write straight to job's output and error files */
		si.dwFlags = STARTF_USESTDHANDLES;
		si.hStdOutput = (HANDLE)_get_osfhandle(script_out);
		si.hStdError = (HANDLE)_get_osfhandle(script_err);
		/* set stdout and stderr to append mode */
		SetFilePointer(si.hStdOutput, (LONG)NULL,
			(PLONG)NULL, FILE_END);
		SetFilePointer(si.hStdError, (LONG)NULL,
			(PLONG)NULL, FILE_END);
	}
	
	/* If we fail to get cmd shell(unlikely), use "cmd.exe" as shell */
	if (0 != get_cmd_shell(cmd_shell, sizeof(cmd_shell)))
		(void)snprintf(cmd_shell, sizeof(cmd_shell) - 1, "cmd.exe");
	
	/*
	 * On Windows spawn mom_open_demux that will take care of running
	 * a multinode job task and redirecting it's output to pbs_demux at MS host
	 * for a single node non-interactive batch job run the command itself
	 * cmdline is already formed
	 */
	if (is_interactive_job || (pjob->ji_numnodes > 1)) {
		if(!nodemux) {
			snprintf(cmdline, _countof(cmdline) -1, "%s /c %s/sbin/mom_open_demux.exe %s", cmd_shell, pbs_conf.pbs_exec_path, pjob->ji_qs.ji_jobid);
			strncat(cmdline, " ", _countof(cmdline) -1);
			strncat(cmdline, pjob->ji_hosts[0].hn_host, _countof(cmdline) -1);
			strncat(cmdline, " ", _countof(cmdline) -1);
		}		strncat(cmdline, "\"", _countof(cmdline) -1);
		strncat(cmdline, argv[0], _countof(cmdline) -1);
		strncat(cmdline, "\"", _countof(cmdline) -1);
		for (i=1; argv[i]; i++) {
			strncat(cmdline, " ", _countof(cmdline) -1);
			strncat(cmdline, argv[i], _countof(cmdline) -1);
		}
	}
	
	if (pwdp->pw_userlogin != INVALID_HANDLE_VALUE) { /* ENTERPRISE MODE */
	
		argv_in = str_to_str_array(cmdline, " ");
		if ((argv_in == NULL) || (argv_in[0] == NULL)) {
	
			if (argv_in != NULL) {
				free_str_array(argv_in);
			}
			exec_bail(pjob, JOB_EXEC_FAIL2, "bad commandline");
			return PBSE_SYSTEM;
		}
	
		progname = strdup(argv_in[0]);
		if (progname == NULL) {
			free_str_array(argv_in);
			exec_bail(pjob, JOB_EXEC_FAIL2, "failed to strdup progname");
			return PBSE_SYSTEM;
		}
	
		env = env_array; /* pass current environment array */
	
		mom_hook_input_init(&hook_input);
		hook_input.pjob = pjob;
		hook_input.progname = progname;
		hook_input.argv = argv_in;
		hook_input.env = env;
	
		mom_hook_output_init(&hook_output);
		hook_output.reject_errcode = &hook_errcode;
	
		hook_output.last_phook = &last_phook;
		hook_output.fail_action = &hook_fail_action;
		hook_output.progname = &progname_out;
		CLEAR_HEAD(argv_list);
		hook_output.argv = &argv_list;
		hook_output.env = &env_str;
	
		switch (mom_process_hooks(HOOK_EVENT_EXECJOB_LAUNCH,
				PBS_MOM_SERVICE_NAME,
				mom_host, &hook_input, &hook_output,
				hook_msg, sizeof(hook_msg), 0)) {
	
			case 0:	/* explicit reject */
				free_str_array(argv_in);
				free(progname_out);
				free_attrlist(&argv_list);
				free(env_str);
	
	
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				return PBSE_SYSTEM;
			case 1:   /* explicit accept */
				if (progname_out == NULL) {
					free_str_array(argv_in);
					free_attrlist(&argv_list);
					free(env_str);
	
					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL progname!");
					return PBSE_SYSTEM;
				}
	
				argv_out = svrattrl_to_str_array(&argv_list);
				if (argv_out == NULL) {
					free_str_array(argv_in);
					free(progname_out);
					free_attrlist(&argv_list);
					free(env_str);
	
					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL argv!");
					return PBSE_SYSTEM;
				}

				/* progname_out now becomes argv[0] */
				/* freeing argv_out[] will automatically */
				/* free progname_out */
				free(argv_out[0]);
				argv_out[0] = progname_out;	
	
				argv_str = str_array_to_str(argv_out,
								" ");
				if (argv_str == NULL) {
	
					free_str_array(argv_in);
					free_attrlist(&argv_list);
					free(env_str);
					free_str_array(argv_out);
	
					exec_bail(pjob, JOB_EXEC_FAIL2,
						"execjob_launch hook returned NULL argv_str!");
					return PBSE_SYSTEM;
				}
				strncpy(cmdline, argv_str, sizeof(cmdline)-1);
				log_event(PBSEVENT_JOB,
					PBS_EVENTCLASS_JOB, LOG_INFO,
					pjob->ji_qs.ji_jobid,
							cmdline);
				free(argv_str);
				free_str_array(argv_out);
	
				if (env_str != NULL) {
					env = str_to_str_array(env_str, ",");
					if (env == NULL) {
						free_str_array(argv_in);
						free_attrlist(&argv_list);
						free(env_str);
						exec_bail(pjob, JOB_EXEC_FAIL2,
							"execjob_launch hook NULL env!");
						return PBSE_SYSTEM;
					}
	
					/* numenv is the total # of */
					/* slots in env_array including */
					/*  unused slots */
					/* curenv is the total # of used */
					/* slots */
					curenv = numenv;
					init_envp(); /* free up all entries */
						     /* in env_array */
					free(env_block);/* since values from */
							/* previous env_array */
	
					env_array = env;
					curenv = 0;
					while(env_array[curenv] != NULL)
						curenv++;
	
					numenv = curenv;
						;
					/* re-populate env_block */
					/* with entries from */
					/* new env_array */
					env_block = make_envp();
					
				}
				break;
			case 2:	  /* no hook script executed - go ahead and accept event */
				break;
			default:
				log_event(PBSEVENT_DEBUG2, PBS_EVENTCLASS_HOOK,
					LOG_INFO, "",
					"execjob_launch hook event: accept req by default");
		}
	
		free_str_array(argv_in);
		free_attrlist(&argv_list);
		free(env_str);
	
		if (!impersonate_user(pwdp->pw_userlogin)) {
			sprintf(log_buffer,
				"failed to ImpersonateLoggedOnUser on %s", mom_host);
			(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment],
				ATTR_comment, NULL, log_buffer);
			log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
			exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
			return PBSE_SYSTEM;
		}
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			rc = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pbs_jobdir, &si, &pi);
		} else {
			rc = CreateProcessAsUser(pwdp->pw_userlogin, NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pjob->ji_grpcache->gc_homedir, &si, &pi);
		}
		(void)revert_impersonated_user();
	
	} else if (strcmpi(pwdp->pw_name, getlogin()) == 0) { /* Personal Mode */
	
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			rc = CreateProcess(NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pbs_jobdir, &si, &pi);
		} else {
			rc = CreateProcess(NULL, cmdline,
				NULL, NULL, TRUE, flags,
				env_block, pjob->ji_grpcache->gc_homedir, &si, &pi);
		}
	} else {
		sprintf(log_buffer, "failed to ImpersonateLoggedOnUser on %s", mom_host);
		(void)decode_str(&pjob->ji_wattr[JOB_ATR_Comment], ATTR_comment, NULL, log_buffer);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
		exec_bail(pjob, JOB_EXEC_FAIL_PASSWORD, NULL);
		return PBSE_SYSTEM;
	}
	
	
	/* restore MOM to its home */
	(void)chdir(mom_home);
	
	if (env_block)
		free(env_block);
	
	if (!rc) {
		sprintf(log_buffer, "CreateProcess(AsUser) err=%d", GetLastError());
		log_err(-1, __func__, log_buffer);
		proc_bail(ptask);
		return PBSE_PERM;
	}
	ptask->ti_hProc = pi.hProcess;
	ptask->ti_qs.ti_sid = pi.dwProcessId;
#ifndef WIN32
	if ((pjob->ji_numnodes > 1) && !no_stdio_sockets) {
#endif
		if (script_out != -1)
			close(script_out);
		if (script_err != -1)
			close(script_err);
#ifndef WIN32
	}
	else {
		if (script_out != -1)
			close(script_out);
		if (script_err != -1)
			close(script_err);
	}
#endif
	script_out = -1;
	script_err = -1;
	
	/*
	 **	Get the job going.
	 */
	rc = AssignProcessToJobObject(pjob->ji_hJob, pi.hProcess);
	if (!rc) {
		log_err(-1, __func__, "AssignProcessToJobObject");
		close_valid_handle(&(pi.hThread));
		proc_bail(ptask);
		return PBSE_SYSTEM;
	}
	
	/*
	 **	After adding process to job
	 */
	ptask->ti_qs.ti_status = TI_STATE_RUNNING;
	(void)task_save(ptask);
	if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING) {
		pjob->ji_qs.ji_state = JOB_STATE_RUNNING;
		pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
		job_save(pjob, SAVEJOB_QUICK);
	}
	(void)sprintf(log_buffer, "task %u started, %s",
		ptask->ti_qs.ti_task, argv[0]);
	log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
		pjob->ji_qs.ji_jobid, log_buffer);
	
	rc = ResumeThread(pi.hThread);
	if (rc == -1) {
		log_err(-1, __func__, "ResumeThread");
		close_valid_handle(&(pi.hThread));
		proc_bail(ptask);
		return PBSE_SYSTEM;
	}
	close_valid_handle(&(pi.hThread));
	
	return PBSE_NONE;
}

/**
 * @brief
 *      Open (create) either standard output or standard error for the job.
 *
 * @param[in] pjob  - pointer to job structure
 * @param[in] which - which file to create, StdOut, StdErr, or Chkpt
 * @param[in] mode  - file open oflag (O_CREAT, O_WRONLY, ...)
 * @param[in] exgid - User's gid
 *
 * @return      int
 * @retval      fd      On success
 * @retval      -1      on failure
 *
 */
int
open_std_file(job *pjob, enum job_file which, int mode, gid_t exgid)
{
	int	fds;
	int	keeping;
	char	*path;
	int     became_admin = 0;

	path = std_file_name(pjob, which, &keeping);

	fds = open(path, mode, _S_IWRITE | _S_IREAD);

	if (pjob->ji_user && pjob->ji_user->pw_name) {

		if ((strcmpi(getlogin(), pjob->ji_user->pw_name) == 0) &&
			(pjob->ji_user->pw_userlogin != INVALID_HANDLE_VALUE)) {
			/* temporarily revert to ADMIN to do secure file */
			(void)revert_impersonated_user();
			
			became_admin =1;
		}

		secure_file2(path,
			pjob->ji_user->pw_name,
			READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED,
			"Administrators", READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED);

		if (became_admin) {   /* go back to being user */
			if (pjob->ji_user->pw_userlogin != INVALID_HANDLE_VALUE) {
				(void)impersonate_user(pjob->ji_user->pw_userlogin);
			}
		}

	}

	return (fds);
}

#else		/* UNIX --------------------------------------------------- */


#define FDMOVE(fd)      if (fd < 3) { \
	int     hold = fcntl(fd, F_DUPFD, 3); \
	(void)close(fd); \
	fd = hold; \
}

/**
 * @brief
 *      validate credentials of user for job.
 *
 * @param[in] pjob - job pointer
 *
 * @return      pointer to structure
 * @retval      structure handle to passwd
 *
 */
struct passwd *
check_pwd(job *pjob)
{
	struct passwd		*pwdp;
	struct group		*grpp;
	char		      **pgnam;
	struct stat		sb;

	pwdp = getpwnam(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str);
	if (pwdp == (struct passwd *)0) {
		(void)sprintf(log_buffer, "No Password Entry for User %s",
			pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str);
		return NULL;
	}
	/* check that home directory is valid */
	if (*pwdp->pw_dir == '\0') {
		sprintf(log_buffer, "null home directory");
		return NULL;
	}
	if (pjob->ji_grpcache == NULL) {
		pjob->ji_grpcache = malloc(sizeof(struct grpcache) +
			strlen(pwdp->pw_dir) + 1);
		if (pjob->ji_grpcache == (struct grpcache *)0) {
			sprintf(log_buffer, "Malloc failed");
			return NULL;
		}
		if (stat(pwdp->pw_dir, &sb) == -1) {
			sprintf(log_buffer, "%s: home directory: %s",
				pjob->ji_qs.ji_jobid, pwdp->pw_dir);
			log_err(errno, "check_pwd", log_buffer);
		}
		strcpy(pjob->ji_grpcache->gc_homedir, pwdp->pw_dir);
	}

	pjob->ji_grpcache->gc_uid = pwdp->pw_uid; /* execution uid */

	/* get the group and supplimentary under which the job is to be run */

	if ((pjob->ji_wattr[(int)JOB_ATR_egroup].at_flags &
		(ATR_VFLAG_SET | ATR_VFLAG_DEFLT)) == ATR_VFLAG_SET) {

		/* execution group specified - not defaulting to login group */

		grpp = getgrnam(pjob->ji_wattr[(int)JOB_ATR_egroup].
			at_val.at_str);
		if (grpp == (struct group *)0) {
			(void)sprintf(log_buffer, "No Group Entry for Group %s",
				pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str);
			return NULL;
		}
		if (grpp->gr_gid != pwdp->pw_gid) {
			pgnam = grpp->gr_mem;
			while (*pgnam) {
				if (!strcmp(*pgnam, pwdp->pw_name))
					break;
				++pgnam;
			}
			if (*pgnam == 0) {
				(void)sprintf(log_buffer, "user not in group");
				return NULL;
			}
		}
		pjob->ji_grpcache->gc_gid = grpp->gr_gid;
	} else {
		/* default to login group */
		pjob->ji_grpcache->gc_gid = pwdp->pw_gid;
	}

	/* perform site specific check on validatity of account */
	if (site_mom_chkuser(pjob))
		return NULL;

	return pwdp;
}

/**
 * @brief
 *	Become the user with specified user name, uid, and gids.
 *	Obtains the current supplement group list and if necessary adds
 *	the user's login group to it,  then changes to the specified group,
 *	new group list, and the specified uid.
 *
 * @param[in] eusrname - the execution user name 
 * @param[in] euid     - the execution uid
 * @param[in] egid     - the execution gid
 * @param[in] rgid     - the login (or real) gid of the user
 *
 * @return int
 * @retval 0  - success
 * @retval -1 - failure to change
 */
int
becomeuser_args(char *eusrname, uid_t euid, gid_t egid, gid_t rgid)
{
	gid_t *grplist = NULL;
	int    i;
	int    numsup;
	static int   maxgroups=0;

	/* obtain the maximum number of groups possible in the list */
	if (maxgroups == 0)
		maxgroups = (int)sysconf(_SC_NGROUPS_MAX);

	if (initgroups(eusrname, egid) != -1) {
		/* allocate an array for the group list */
		grplist = calloc((size_t)maxgroups, sizeof(gid_t));
		if (grplist == NULL)
			return -1;
		/* get the current list of groups */
		numsup = getgroups(maxgroups, grplist);
		for (i=0; i<numsup; ++i) {
			if (grplist[i] == rgid)
				break;
		}
		if (i == numsup) {
			/* need to add primary group to list */
			if (numsup == maxgroups) {
				/* cannot, list already at max size */
				free(grplist);
				return -1;
			}
			grplist[numsup++] = rgid;
		}
		if ((setgroups((size_t)numsup, grplist) != -1) &&
		    (setgid(egid) != -1) &&
		    (setuid(euid) != -1)) {
			free(grplist);
			return 0;
		}
	}
	if (grplist)
		free(grplist);
	return -1;
}

/**
 * @brief
 *	Become the user using information sent with the job and in the cached
 *	password information in the job structure if available.
 *	
 *	Picks up the execution user name from the euser attribute, the euid
 *	and egid from the mom subarea of the job structure and the login gid
 *	from the cached password info if that has been set.  Otherwise use
 *	the egid.
 *
 *	The real work is done by passing the above to becomeuser_args().
 *
 * @param[in] pjob - pointer to the job structure
 *
 * @return int
 * @retval 0  - success
 * @retval -1 - failure to change
 */
int
becomeuser(job *pjob)
{
	gid_t rgid;
	if (pjob->ji_grpcache != NULL)
		rgid = pjob->ji_grpcache->gc_rgid;
	else
		rgid = pjob->ji_qs.ji_un.ji_momt.ji_exgid;
	if (becomeuser_args(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, pjob->ji_qs.ji_un.ji_momt.ji_exuid, pjob->ji_qs.ji_un.ji_momt.ji_exgid, rgid) == -1) {
		fprintf(stderr, "unable to set user privileges, errno = %d\n",
			errno);
		return -1;
	} else
		return 0;
}

/**
 * @brief
 *      exec_bail - called when the start of a job fails to clean up
 *
 * @par Functionality:
 *      Logs the message if one is passed in.
 *      Sends IM_ABORT_JOB to the sisters.
 *      sets the job's substate to JOB_SUBSTATE_EXITING, sets the job's
 *      exit code and sets exiting_tasks so an obit is sent for the job.
 *      The job's standard out/err are closed and then resources are released.
 *
 * @param[in]   pjob - pointer to job structure
 * @param[in]   code - the error code for the exit value, typically JOB_EXEC_*
 * @param[in]   txt  - a message to log or NULL if none or already logged
 *
 * @return      None
 *
 * @par MT-safe: likely no
 *
 */
void
exec_bail(job *pjob, int code, char *txt)
{
	int	nodes;

	/* log message passed in if one was */
	if (txt != NULL) {
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, txt);
	}

	nodes = send_sisters(pjob, IM_ABORT_JOB);
	if (nodes != pjob->ji_numnodes-1) {
		sprintf(log_buffer,
			"sent %d ABORT requests, should be %d",
			nodes, pjob->ji_numnodes-1);
		log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
	}
	pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXITING;
	pjob->ji_qs.ji_un.ji_momt.ji_exitstat = code;
	exiting_tasks = 1;
	if (pjob->ji_stdout > 0)
		(void)close(pjob->ji_stdout);
	if (pjob->ji_stderr > 0)
		(void)close(pjob->ji_stderr);
	return;
}

/**
 * @brief
 *      open_pty - open slave side of master/slave pty
 *
 * @param[in] pjob - job pointer
 *
 * @retval      int
 * @retval      pty descriptor  Success
 *
 */
static int
open_pty(job *pjob)
{
	char	*name;
	int	 pts;

	/* Open the slave pty as the controlling tty */

	name = pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str;

	if ((pts = open(name, O_RDWR, 0600)) < 0) {
		log_err(errno, "open_pty", name);
	} else {

		FDMOVE(pts);

		(void)fchmod(pts, 0620);
		(void)fchown(pts, pjob->ji_qs.ji_un.ji_momt.ji_exuid,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
#if defined(_CRAY) && !defined(__sv2)
		(void)ioctl(0, TCCLRCTTY, 0);
		(void)ioctl(pts, TCSETCTTY, 0); /* make controlling */
#endif	/* _CRAY */
#if defined(__osf__)
		(void)ioctl(pts, TIOCSCTTY, 0);	/* make controlling */
#endif
	}
	return (pts);
}

/**
 * @brief
 *      open_std_out_err - open standard out and err to files
 *
 * @param[in] pjob - job pointer
 *
 * @return      int
 * @retval      0       Success
 * @retval      -1      Error
 *
 */
static int
open_std_out_err(job *pjob)
{
	int	   i;
	int	   file_out = -2;
	int	   file_err = -2;
	int	   filemode = O_CREAT | O_WRONLY | O_APPEND;

	/* if std out/err joined (set and !="n"),which file is first */

	i = is_joined(pjob);
	if (i == 1) {
		file_out = open_std_file(pjob, StdOut, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
		file_err = dup(file_out);
	} else if (i == -1) {
		file_err = open_std_file(pjob, StdErr, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
		file_out = dup(file_err);
	}

	if (file_out == -2)
		file_out = open_std_file(pjob, StdOut, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
	if (file_err == -2)
		file_err = open_std_file(pjob, StdErr, filemode,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);
	if ((file_out < 0 || file_err < 0)) {
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_NOTICE,
			pjob->ji_qs.ji_jobid,
			"Unable to open standard output/error");
		return -1;
	}

	FDMOVE(file_out);	/* make sure descriptor > 2       */
	FDMOVE(file_err);	/* so don't clobber stdin/out/err */
	if (file_out != 1) {
		(void)close(1);
		(void)dup(file_out);
		(void)close(file_out);
	}
	if (file_err != 2) {
		(void)close(2);
		(void)dup(file_err);
		(void)close(file_err);
	}
	return 0;
}

/**
 * @brief
 *      mktmpdir - make temporary directory(s)
 *      A temporary directory is created and the name is
 *      placed in an environment variable.
 *
 * @param[in] jobid - job id
 * @param[in] uid - user id
 * @param[in] gid - group id
 * @param[in] vtab - pointer to variable table
 *
 * @return      int
 * @retval      0               Success
 * @retval      JOB_EXEC_FAIL1  failure to make directory
 *
 */
int
mktmpdir(char *jobid, uid_t uid, gid_t gid, struct var_table *vtab)
{
	char	*tmpdir;

	tmpdir = tmpdirname(jobid);
	if (mkdir(tmpdir, 0777) == -1) {
		if (errno == EEXIST)
			return 0;
		sprintf(log_buffer, "%s: mkdir: %s",
			jobid, tmpdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	if (chown(tmpdir, uid, gid) == -1) {
		sprintf(log_buffer, "%s: chown: %s",
			jobid, tmpdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	/* Only set TMPDIR if everything succeeded to this point. */
	if (vtab) {
		bld_env_variables(vtab, "TMPDIR", tmpdir);
		/* For Windows, also set TEMP and TMP. */
		bld_env_variables(vtab, "TEMP", tmpdir);
		bld_env_variables(vtab, "TMP", tmpdir);
	}
	return 0;
}

/**
 * @brief
 *      mkjobdir - make the staging and execution directory
 *      A per-job staging and execution directory is created.
 *      If the parent of the directory is the user's home, it is made while
 *      operating with the user's privilege.  Otherwise, it is made as root
 *      and then changed as it would be in "job_dir_root" which is root owned.
 *
 * @param[in] jobid - job id
 * @param[in] jobdir - job directory
 * @param[in] uid - user id
 * @param[in] gid - group id
 * @param[in] vtab - pointer to variable table
 *
 * @return      int
 * @retval      0       Success
 * @retval      -1      Error
 *
 */
int
mkjobdir(char *jobid, char *jobdir, uid_t uid, 
		gid_t gid, struct var_table *vtab;)
{
	if (mkdir(jobdir, 0777) == -1) {
		if (errno == EEXIST)
			return 0;
		sprintf(log_buffer, "%s: mkdir: %s",
			jobid, jobdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	if (chown(jobdir, uid, gid) == -1) {
		sprintf(log_buffer, "%s: chown: %s",
			jobid, jobdir);
		log_err(errno, __func__, log_buffer);
		return JOB_EXEC_FAIL1;
	}
	return 0;
}

/**
 * @brief	Used by MOM superior to start the shell process for a job.
 * 		(Windows version)
 *
 * @param[in]	pjob - pointer to the job whose initial shell is
 *		being spawned.
 */
void
finish_exec(job *pjob)
{
	char                    **argv = NULL;
	char                    buf[2*MAXPATHLEN+5];
	pid_t                   cpid;
	struct passwd           *pwdp;          /* for uid, shell, home dir */
	int                     i, j;
	pbs_socklen_t           len;
	int                     is_interactive = 0;
	int                     numthreads;
	attribute               *pattr;
	attribute               *pattri;
	char                    *phost;
#if SHELL_INVOKE == 1
	int                     pipe_script[2];
#endif
	char                    *pts_name;      /* name of slave pty */
	int                     ptc = -1;       /* fd for master pty */
	int                     pts;            /* fd for slave pty */
	int                     qsub_sock, old_qsub_sock;
	char                    *shell;
	int                     jsmpipe[2];     /* job starter to MOM for sid */
	int                     upfds;
	int                     mjspipe[2];     /* MOM to job starter for ack */
	int                     downfds;
	int                     port_out, port_err;
	struct startjob_rtn     sjr;
	char                    *termtype;
	pbs_task                        *ptask;
	struct  array_strings   *vstrs;
	struct  sockaddr_in     saddr;
	int                     nodemux = 0;
	char                    *pbs_jobdir; /* staging and execution directory of this job */

	memset(&sjr, 0, sizeof(sjr));
	pattr = &pjob->ji_wattr[(int)JOB_ATR_nodemux];
	if (pattr->at_flags & ATR_VFLAG_SET)
		nodemux = (int)pattr->at_val.at_long;


	if ((i = job_setup(pjob, &pwdp)) != JOB_EXEC_OK) {
		exec_bail(pjob, i, NULL);
		return;
	}

	/* wait until after job_setup to call jobdirname(), we need the user's home info */
	pbs_jobdir = jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir);

	/* If job has been checkpointed, restart from the checkpoint image */

	if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHKPT) ||
		(pjob->ji_qs.ji_svrflags & JOB_SVFLG_ChkptMig)) {
		if ((i = local_restart(pjob, NULL)) != 0) {
			post_restart(pjob, i);
			exec_bail(pjob, (i == PBSE_CKPBSY) ?
				JOB_EXEC_RETRY : JOB_EXEC_FAIL2, NULL);
		}
		return;
	}

	if (pjob->ji_numnodes == 1 || nodemux) {
		port_out = -1;
		port_err = -1;
	}
	else {
		/*
		 ** Get port numbers from file decriptors in job struct.  The
		 ** sockets are stored there so they can be closed later as
		 ** Main MOM will not need them after the job is going.
		 */
		len = sizeof(saddr);
		if (getsockname(pjob->ji_stdout,
			(struct sockaddr *)&saddr, &len) == -1) {
			(void)sprintf(log_buffer, "getsockname on stdout");
			exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
			return;
		}
		port_out = (int)ntohs(saddr.sin_port);

		len = sizeof(saddr);
		if (getsockname(pjob->ji_stderr,
			(struct sockaddr *)&saddr, &len) == -1) {
			(void)sprintf(log_buffer, "getsockname on stderr");
			exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
			return;
		}
		port_err = (int)ntohs(saddr.sin_port);
	}

	pattri = &pjob->ji_wattr[(int)JOB_ATR_interactive];
	if ((pattri->at_flags & ATR_VFLAG_SET) &&
		(pattri->at_val.at_long != 0)) {

		is_interactive = 1;

		/*
		 * open a master pty, need to do it here before we fork,
		 * to save the slave name in the master's job structure
		 */

		if ((ptc = open_master(&pts_name)) < 0) {
			log_err(errno, __func__ , "cannot open master pty");
			exec_bail(pjob, JOB_EXEC_RETRY, NULL);
			return;
		}
		FDMOVE(ptc)

		/* save pty name in job output/error file name */

		pattr = &pjob->ji_wattr[(int)JOB_ATR_outpath];
		job_attr_def[(int)JOB_ATR_outpath].at_free(pattr);
		(void)job_attr_def[(int)JOB_ATR_outpath].at_decode(
			pattr, (char *)0, (char *)0, pts_name);
		pattr = &pjob->ji_wattr[(int)JOB_ATR_errpath];
		job_attr_def[(int)JOB_ATR_errpath].at_free(pattr);
		(void)job_attr_def[(int)JOB_ATR_errpath].at_decode(
			pattr, (char *)0, (char *)0, pts_name);

#if SHELL_INVOKE == 1

	} else {
		/* need a pipe on which to write the shell script       */
		/* file name to the input of the shell                  */

		if (pipe(pipe_script) == -1) {
			(void)sprintf(log_buffer,
				"Failed to create shell name pipe");
			exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
			return;
		}
#endif /* SHELL_INVOKE */

	}

	/* create pipes between MOM and the job starter    */
	/* fork the job starter which will become the job */

	if ((pipe(mjspipe) == -1) || (pipe(jsmpipe) == -1)) {
		i = -1;

	} else {

		i = 0;

		/* make sure pipe file descriptors are above 2 */

		if (jsmpipe[1] < 3) {
			upfds = fcntl(jsmpipe[1], F_DUPFD, 3);
			(void)close(jsmpipe[1]);
		} else
			upfds = jsmpipe[1];
		if (mjspipe[0] < 3) {
			downfds = fcntl(mjspipe[0], F_DUPFD, 3);
			(void)close(mjspipe[0]);
		} else
			downfds = mjspipe[0];
	}
	if ((i == -1) || (upfds < 3) || (downfds < 3)) {
		(void)sprintf(log_buffer, "Failed to create communication pipe");
		exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
		return;
	}
	if ((ptask = momtask_create(pjob)) == NULL) {
		(void)sprintf(log_buffer, "Task creation failed");
		exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
		return;
	}

	pjob->ji_qs.ji_stime = time_now;
	pjob->ji_sampletim   = time_now;

	/*
	 ** Fork the child that will become the job.
	 */
	cpid = fork_me(-1);
	if (cpid > 0) {
		char    *s, *d, holdbuf[2*MAXPATHLEN+5];

		/* the parent side, still the main man, uhh that is MOM */

		(void)close(upfds);
		(void)close(downfds);
		if (ptc >= 0)
			(void)close(ptc);

		if (*pjob->ji_qs.ji_fileprefix != '\0')
			sprintf(buf, "%s%s%s", path_jobs,
				pjob->ji_qs.ji_fileprefix, JOB_SCRIPT_SUFFIX);
		else
			sprintf(buf, "%s%s%s", path_jobs,
				pjob->ji_qs.ji_jobid, JOB_SCRIPT_SUFFIX);
		(void)chown(buf, pjob->ji_qs.ji_un.ji_momt.ji_exuid,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid);

		/* add escape in front of brackets */
		for (s=buf, d=holdbuf; *s; s++, d++) {
			if (*s == '[' || *s == ']')
				*d++ = '\\';
			*d = *s;
		}
		*d = '\0';
		strcpy(buf, holdbuf);
		DBPRT(("shell: %s\n", buf))
#if SHELL_INVOKE == 1
		if (is_interactive == 0) {
			int k;

			/* pass name of shell script on pipe    */
			/* will be stdin of shell               */

			(void)close(pipe_script[0]);

			/* if in "sandbox=PRIVATE" mode, prepend the script name on the pipe */
			/* with "cd $PBS_JOBDIR;" command */
			if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
				(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE")== 0)) {
				sprintf(buf, "cd %s;%s", pbs_jobdir, holdbuf);
			}

			(void)strcat(buf, "\n");        /* setup above */
			i = strlen(buf);
			j = 0;
			while (j < i) {
				if ((k=write(pipe_script[1], buf+j, i-j)) < 0) {
					if (errno == EINTR)
						continue;
					break;
				}
				j += k;
			}
			(void)close(pipe_script[1]);
		}
#endif  /* SHELL_INVOKE */

		/* now we read the session id or error */
		i = readpipe(jsmpipe[0], &sjr, sizeof(sjr));
		j = errno;
		(void)close(jsmpipe[0]);
		if (i != sizeof(sjr)) {
			sprintf(log_buffer,
				"read of pipe for pid job %s got %d not %d",
				pjob->ji_qs.ji_jobid,
				i, (int)sizeof(sjr));
			log_err(j, __func__, log_buffer);
			(void)sprintf(log_buffer, "start failed, improper sid");
			(void)close(mjspipe[1]);
			exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
			return;
		}
		/* send back as an acknowledgement that MOM got it */
		(void)writepipe(mjspipe[1], &sjr, sizeof(sjr));
		(void)close(mjspipe[1]);
		DBPRT(("%s: read start return %d %d\n", __func__,
			sjr.sj_code, sjr.sj_session))

		/*
		 ** Set the global id before exiting on error so any
		 ** information can be put into the job struct first.
		 */
		set_globid(pjob, &sjr);
		if (sjr.sj_code < 0) {
#ifdef MOM_ALPS
			/* we couldn't start the job so refresh the inventory */
			call_hup = HUP_INIT;
#endif
			(void)sprintf(log_buffer, "job not started, %s %d",
				(sjr.sj_code==JOB_EXEC_RETRY)?
				"Retry" : "Failure", sjr.sj_code);
			exec_bail(pjob, sjr.sj_code, log_buffer);
			return;
		}

		ptask->ti_qs.ti_sid = sjr.sj_session;
		ptask->ti_qs.ti_status = TI_STATE_RUNNING;
#ifdef  _SX
		ptask->ti_qs.ti_u.ti_ext.ti_parent = sjr.sj_parent;
		ptask->ti_qs.ti_u.ti_ext.ti_jid = sjr.sj_jid;
#endif
		strcpy(ptask->ti_qs.ti_parentjobid, pjob->ji_qs.ji_jobid);
		if (task_save(ptask) == -1) {
			(void)sprintf(log_buffer, "Task save failed");
			exec_bail(pjob, JOB_EXEC_RETRY, log_buffer);
			return;
		}

#if MOM_CSA
		/*
		 ** if capability present, cause two workload management
		 ** records to be created for this phase of the job
		 */

		write_wkmg_record(WM_RECV, WM_RECV_NEW, pjob);
		write_wkmg_record(WM_INIT, WM_INIT_START, pjob);
#endif

		if (pjob->ji_numnodes > 1 && !nodemux) {
			/*
			 ** Put port numbers into job struct and close sockets.
			 ** The job uses them to talk to demux, but main MOM
			 ** doesn't need them.   The port numbers are stored
			 ** here for use in start_process(), to connect to
			 ** pbs_demux.
			 */
			(void)close(pjob->ji_stdout);
			pjob->ji_stdout = port_out;
			(void)close(pjob->ji_stderr);
			pjob->ji_stderr = port_err;
		}

		/* return from the starter indicated the job is a go ... */
		/* record the start time and session/process id          */

		pjob->ji_wattr[(int)JOB_ATR_session_id].at_val.at_long
		= sjr.sj_session;
		pjob->ji_wattr[(int)JOB_ATR_session_id].at_flags =
			ATR_VFLAG_SET | ATR_VFLAG_MODIFY;

		/* record job working directory in jobdir attribute */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			/* job is handled in jobdir */
			decode_str(&pjob->ji_wattr[JOB_ATR_jobdir],
				ATTR_jobdir, NULL, pbs_jobdir);
		} else {
			/* job is handled in user HOME */
			decode_str(&pjob->ji_wattr[JOB_ATR_jobdir],
				ATTR_jobdir, NULL, pwdp->pw_dir);
		}
		pjob->ji_wattr[(int)JOB_ATR_jobdir].at_flags =
			ATR_VFLAG_SET | ATR_VFLAG_MODIFY;

		pjob->ji_qs.ji_state = JOB_STATE_RUNNING;
		pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
		job_save(pjob, SAVEJOB_QUICK);

		if (mom_get_sample() == PBSE_NONE) {
			time_resc_updated = time_now;
			(void)mom_set_use(pjob);
		}
		/* these are set for update_ajob_status() so that it will */
		/* return them to the Server on the first update below.   */
		/* Later the corresponding code should be removed from req_commit() */

		pjob->ji_wattr[(int)JOB_ATR_errpath].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_outpath].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_session_id].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_altid].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_state].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_substate].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_jobdir].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_altid2].at_flags |= ATR_VFLAG_MODIFY;
		pjob->ji_wattr[(int)JOB_ATR_acct_id].at_flags |= ATR_VFLAG_MODIFY;

		update_ajob_status(pjob);
		next_sample_time = min_check_poll;
		sprintf(log_buffer, "Started, pid = %d", sjr.sj_session);
		/* the message is "logged" in req_commit() */

		return;

	} else if (cpid < 0) {
		(void)sprintf(log_buffer, "Fork failed in %s: %d",
			__func__, errno);
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, log_buffer);
		exec_bail(pjob, JOB_EXEC_RETRY, NULL);
		return;
	}
	/************************************************/
	/*                                              */
	/* The child process - will become THE JOB      */
	/*                                              */
	/************************************************/

	(void)close(jsmpipe[0]);
	(void)close(mjspipe[1]);

	CLR_SJR(sjr)    /* clear structure used to return info to parent */

	/*
	 * find which shell to use, one specified or the login shell
	 */
	shell = set_shell(pjob, pwdp);  /* in the machine dependent section */

	/*
	 * set up the Environmental Variables to be given to the job
	 */
	vstrs = pjob->ji_wattr[(int)JOB_ATR_variables].at_val.at_arst;
	vtable.v_ensize = vstrs->as_usedptr + num_var_else + num_var_env +
		EXTRA_ENV_PTRS;
	vtable.v_used   = 0;
	vtable.v_envp = (char **)malloc(vtable.v_ensize * sizeof(char *));

	/*  First variables from the local environment */

	for (j = 0; j < num_var_env; ++j)
		bld_env_variables(&vtable, environ[j], (char *)0);

	/* Second, the variables passed with the job.  They may */
	/* be overwritten with new correct values for this job  */

	for (j = 0; j < vstrs->as_usedptr; ++j)
		bld_env_variables(&vtable, vstrs->as_string[j], (char *)0);

	/* .. Next the critical variables: home, path, logname, ... */
	/* these may replace some passed in with the job            */

	/* HOME */
	bld_env_variables(&vtable, variables_else[0], pwdp->pw_dir); /* HOME */

	/* LOGNAME */
	bld_env_variables(&vtable, variables_else[1], pwdp->pw_name);

	/* PBS_JOBNAME */
	bld_env_variables(&vtable, variables_else[2],
		pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str);

	/* PBS_JOBID */
	bld_env_variables(&vtable, variables_else[3], pjob->ji_qs.ji_jobid);

	/* PBS_QUEUE */
	bld_env_variables(&vtable, variables_else[4],
		pjob->ji_wattr[(int)JOB_ATR_in_queue].at_val.at_str);

	/* SHELL */
	bld_env_variables(&vtable, variables_else[5], shell);

	/* USER, for compatability */
	bld_env_variables(&vtable, variables_else[6], pwdp->pw_name);

	/* PBS_JOBCOOKIE */
	bld_env_variables(&vtable, variables_else[7],
		pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str);

	/* PBS_NODENUM */
	sprintf(buf, "%d", pjob->ji_nodeid);
	bld_env_variables(&vtable, variables_else[8], buf);

	/* PBS_TASKNUM */
	sprintf(buf, "%u", ptask->ti_qs.ti_task);
	bld_env_variables(&vtable, variables_else[9], buf);

	/* PBS_MOMPORT */
	sprintf(buf, "%d", pbs_rm_port);
	bld_env_variables(&vtable, variables_else[10], buf);

	/* OMP_NUM_THREADS and NCPUS eq to number of cpus */

	numthreads = pjob->ji_vnods[0].vn_threads;
	sprintf(buf, "%d", numthreads);
	bld_env_variables(&vtable, variables_else[12], buf);
	bld_env_variables(&vtable, "NCPUS", buf);

	/* PBS_NODEFILE */

	sprintf(buf, "%s/aux/%s", pbs_conf.pbs_home_path, pjob->ji_qs.ji_jobid);
	bld_env_variables(&vtable, variables_else[11], buf);

	if ((nhow = fopen(buf, "w")) == NULL) {
		sprintf(log_buffer, "cannot open %s", buf);
		log_err(errno, __func__, log_buffer);
		starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
	}
	/*
	 **      The file must be owned by root and readable by
	 **      the user.  We take the easy way out and make
	 **      it readable by anyone.
	 */
	if (fchmod(fileno(nhow), 0644) == -1) {
		sprintf(log_buffer, "cannot chmod %s", buf);
		log_err(errno, __func__, log_buffer);
		fclose(nhow);
		starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
	}
	/* write each node name out once per vnod and entry */
	vnodenum = pjob->ji_numvnod;
	for (j=0; j<vnodenum; j++) {
		if (pjob->ji_vnods[j].vn_hname == NULL) {
			size_t len;
			char  *pdot;

			/* we want to write just the short name of the host */
			if ((pdot = strchr(pjob->ji_vnods[j].vn_host->hn_host, '.')) !=
				NULL)
				len = (size_t)(pdot - pjob->ji_vnods[j].vn_host->hn_host);
			else
				len = strlen(pjob->ji_vnods[j].vn_host->hn_host);
			fprintf(nhow, "%.*s\n", (int)len,
				pjob->ji_vnods[j].vn_host->hn_host);
		} else
			fprintf(nhow, "%s\n", pjob->ji_vnods[j].vn_hname);
	}
	fclose(nhow);

	/* PBS_ACCOUNT */
	if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET)
		bld_env_variables(&vtable, variables_else[13],
			pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str);

	/* If an Sub job of an Array job, put in the index */

	if (strchr(pjob->ji_qs.ji_jobid, (int)'[') != NULL) {
		char *pparent;
		char *pindex;

		get_index_and_parent(pjob->ji_qs.ji_jobid, &pparent, &pindex);
		bld_env_variables(&vtable, variables_else[14], pindex);
		bld_env_variables(&vtable, variables_else[15], pparent);
	}

	/* Add TMPDIR to environment */
	j = mktmpdir(pjob->ji_qs.ji_jobid,
		pjob->ji_qs.ji_un.ji_momt.ji_exuid,
		pjob->ji_qs.ji_un.ji_momt.ji_exgid,
		&vtable);
	if (j != 0) {
		starter_return(upfds, downfds, j, &sjr);
	}

	/* set PBS_JOBDIR */
	if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
		(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
		/* Add PBS_JOBDIR if it doesn't already exist */
		j = mkjobdir(pjob->ji_qs.ji_jobid,
			pbs_jobdir,
			pjob->ji_qs.ji_un.ji_momt.ji_exuid,
			pjob->ji_qs.ji_un.ji_momt.ji_exgid,
			&vtable);
		if (j != 0) {
			sprintf(log_buffer, "unable to create the job directory %s", pbs_jobdir);
			log_err(errno, __func__, log_buffer);
			starter_return(upfds, downfds, j, &sjr); /* exits */
		}
		bld_env_variables(&vtable, "PBS_JOBDIR", pbs_jobdir);
	} else {
		bld_env_variables(&vtable, "PBS_JOBDIR", pwdp->pw_dir);
	}

	/* specific system related variables */
	j = set_mach_vars(pjob, &vtable);
	if (j != 0) {
		starter_return(upfds, downfds, j, &sjr);        /* exits */
	}

	if (pjob->ji_wattr[(int)JOB_ATR_umask].at_flags & ATR_VFLAG_SET) {
		sprintf(buf, "%ld", pjob->ji_wattr[(int)JOB_ATR_umask].
			at_val.at_long);
		sscanf(buf, "%o", &j);
		umask(j);
	} else {
		umask(077);
	}

	mom_unnice();

	if (is_interactive) {
		struct  sigaction       act;

		/*************************************************************************/
		/*              We have an "interactive" job, connect the standard       */
		/*              streams to a socket connected to qsub.                   */
		/*************************************************************************/

		sigemptyset(&act.sa_mask);
#ifdef SA_INTERRUPT
		act.sa_flags   = SA_INTERRUPT;
#else
		act.sa_flags   = 0;
#endif /* SA_INTERRUPT */
		act.sa_handler = no_hang;
		(void)sigaction(SIGALRM, &act, (struct sigaction *)0);
		alarm(30);


		/* Set environment to reflect interactive */

		bld_env_variables(&vtable, "PBS_ENVIRONMENT", "PBS_INTERACTIVE");

		/* get host where qsub resides */

		phost = arst_string("PBS_O_HOST",
			&pjob->ji_wattr[(int)JOB_ATR_variables]);
		if ((phost == (char *)0) ||
			((phost = strchr(phost, (int)'=')) == (char *)0)) {
			log_joberr(-1, __func__, "PBS_O_HOST not set",
				pjob->ji_qs.ji_jobid);
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		qsub_sock = conn_qsub(phost+1, pattri->at_val.at_long);
		if (qsub_sock < 0) {
			sprintf(log_buffer, "cannot open qsub sock for %s",
				pjob->ji_qs.ji_jobid);
			log_err(errno, __func__ , log_buffer);
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		old_qsub_sock = qsub_sock;
		FDMOVE(qsub_sock);

		if (qsub_sock != old_qsub_sock) {

			if (CS_remap_ctx(old_qsub_sock, qsub_sock) != CS_SUCCESS) {

				(void)CS_close_socket(old_qsub_sock);
				starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
			}
		}

		/* send job id as validation to qsub */

		if (CS_write(qsub_sock, pjob->ji_qs.ji_jobid, PBS_MAXSVRJOBID+1) !=
			PBS_MAXSVRJOBID+1) {
			log_err(errno, __func__ , "cannot write jobid");
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		/* receive terminal type and window size */

		if ((termtype = rcvttype(qsub_sock)) == (char *)0)
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);

		bld_env_variables(&vtable, termtype, (char *)0);

		if (rcvwinsize(qsub_sock) == -1)
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);

		/* turn off alarm set around qsub connect activities */

		alarm(0);
		act.sa_handler = SIG_DFL;
		act.sa_flags   = 0;
		(void)sigaction(SIGALRM, &act, (struct sigaction *)0);

		/* set up the Job session */

		j = set_job(pjob, &sjr);
		if (j < 0) {
			if (j == -1) {
				/* set_job didn't leave message in log_buffer */
				(void)strcpy(log_buffer, "Unable to set session");
			}
			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB,
				LOG_NOTICE, pjob->ji_qs.ji_jobid, log_buffer);
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		/* Open the slave pty as the controlling tty */

		if ((pts = open_pty(pjob)) < 0) {
			log_err(errno, __func__, "cannot open slave");
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		act.sa_handler = SIG_IGN;       /* setup to ignore SIGTERM */

#ifdef IRIX6_CPUSET
#ifdef  sgi
#ifdef  SGI_SETPSARGS
		/* Set args listed by ps to include job id and role */
		(void)sprintf(log_buffer,
			"%s nanny (write)", pjob->ji_qs.ji_jobid);
		(void)syssgi(SGI_SETPSARGS,
			log_buffer, strlen(log_buffer));
#endif  /* SGI_SETPSARGS */
#endif  /* sgi */
#endif  /* IRIX6_CPUSET */

		writerpid = fork();
		if (writerpid == 0) {
			/* child is "writer" process */

			(void)sigaction(SIGTERM, &act, NULL);

			(void)close(upfds);
			(void)close(downfds);
			(void)close(pts);

			mom_writer(qsub_sock, ptc);

			shutdown(qsub_sock, 2);
			exit(0);

		} else if (writerpid > 0) {
			/*
			 ** parent -- it first runs the prolog then forks
			 ** again.  the child becomes the job while the
			 ** parent becomes the reader.
			 */

			(void)close(1);
			(void)close(2);
			(void)dup2(pts, 1);
			(void)dup2(pts, 2);
			fflush(stdout);
			fflush(stderr);
			set_termcc(pts);        /* set terminal control char */
			(void)setwinsize(pts);  /* set window size to qsub's */

			/* run prolog */

			if (run_pelog(PE_PROLOGUE,
				path_prolog, pjob,
				PE_IO_TYPE_ASIS) != 0) {
				(void)fprintf(stderr,
					"Could not run prolog: %s\n",
					log_buffer);
				starter_return(upfds, downfds,
					JOB_EXEC_FAIL2, &sjr);
			}

			shellpid = fork();
			if (shellpid == 0) {

				/*********************************************/
				/* child - this will be the interactive job  */
				/* i/o is to slave tty                       */
				/*********************************************/

				(void)close(0);
				(void)dup2(pts, 0);
				fflush(stdin);

				(void)close(ptc);       /* close master side */
				(void)close(pts);       /* dup'ed above */
				(void)close(qsub_sock);

				/* continue setting up and exec-ing shell */

			} else {
				if (shellpid > 0) {
					/* fork, parent is "reader" process  */
					(void)sigaction(SIGTERM, &act, NULL);

					(void)close(pts);
					(void)close(upfds);
					(void)close(downfds);
					(void)close(1);
					(void)close(2);

					sigemptyset(&act.sa_mask);
					act.sa_flags   = SA_NOCLDSTOP;
					act.sa_handler = catchinter;
					(void)sigaction(SIGCHLD, &act,
						(struct sigaction *)0);

					mom_reader_go = 1;
					/* prepare shell command "cd $PBS_JOBDIR" if in sandbox=PRIVATE mode */
					if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
						(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
						sprintf(buf, "cd %s\n", pbs_jobdir);
					} else {
						buf[0] = '\0';
					}
					mom_reader(qsub_sock, ptc, buf);
				}
				else {
					log_err(errno,  __func__,
						"cant fork reader");
				}

				/* make sure qsub gets EOF */

				shutdown(qsub_sock, 2);

				/* change pty back to available after */
				/* job is done */
				(void)chmod(pts_name, 0666);
				(void)chown(pts_name, 0, 0);
				exit(0);
			}
		} else { /* error */
			log_err(errno, __func__ , "cannot fork nanny");

			/* change pty back to available */
			(void)chmod(pts_name, 0666);
			(void)chown(pts_name, 0, 0);

			starter_return(upfds, downfds, JOB_EXEC_RETRY, &sjr);
		}

	} else {

		/*************************************************************************/
		/*              We have a "normal" batch job, connect the standard       */
		/*              streams to files                                         */
		/*************************************************************************/

		/* set Environment to reflect batch */

		bld_env_variables(&vtable, "PBS_ENVIRONMENT", "PBS_BATCH");
		bld_env_variables(&vtable, "ENVIRONMENT", "BATCH");

#if SHELL_INVOKE == 1
		/* if passing script file name as input to shell */

		(void)close(pipe_script[1]);
		script_in = pipe_script[0];
#else   /* SHELL_INVOKE == 0 */
		/* if passing script itself as input to shell */

		(void)strcpy(buf, path_jobs);
		if (*pjob->ji_qs.ji_fileprefix != '\0')
			(void)strcat(buf, pjob->ji_qs.ji_fileprefix);
		else
			(void)strcat(buf, pjob->ji_qs.ji_jobid);
		(void)strcat(buf, JOB_SCRIPT_SUFFIX);
		if ((script_in = open(buf, O_RDONLY, 0)) < 0) {
			if (errno == ENOENT)
				script_in = open("/dev/null", O_RDONLY, 0);
		}
#endif  /* SHELL_INVOKE */

		if (script_in < 0) {
			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
				pjob->ji_qs.ji_jobid,
				"Unable to open script");
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}
		FDMOVE(script_in);      /* make sure descriptor > 2       */
		if (script_in != 0) {
			(void)close(0);
			(void)dup(script_in);
			(void)close(script_in);
		}

		if (open_std_out_err(pjob) == -1) {
			starter_return(upfds, downfds, JOB_EXEC_FAIL1, &sjr);
		}

		/* set up the Job session */

		j = set_job(pjob, &sjr);
		if (j < 0) {
			if (j == -1) {
				/* set_job didn't leave message in log_buffer */
				(void)strcpy(log_buffer, "Unable to set session");
			}
			/* set_job leaves message in log_buffer */
			(void)fprintf(stderr, "%s\n", log_buffer);

			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_NOTICE,
				pjob->ji_qs.ji_jobid, log_buffer);

			if (j == -3)
				j = JOB_EXEC_FAIL2;
			else
				j = JOB_EXEC_RETRY;
			starter_return(upfds, downfds, j, &sjr);
		}

		/* run prolog */

		if ((j = run_pelog(PE_PROLOGUE,
			path_prolog, pjob, PE_IO_TYPE_ASIS)) == 1) {
			/* abort job */
			(void)fprintf(stderr,
				"Could not run prolog: %s\n", log_buffer);
			starter_return(upfds, downfds, JOB_EXEC_FAIL2, &sjr);
		} else if (j != 0) {
			/* requeue job */
			starter_return(upfds, downfds, JOB_EXEC_RETRY, &sjr);
		}

	}

	/*************************************************************************/
	/*      Set resource limits                                              */
	/*      Both normal batch and interactive job come through here          */
	/*************************************************************************/

	pjob->ji_wattr[(int)JOB_ATR_session_id].at_val.at_long = sjr.sj_session;

	if (site_job_setup(pjob) != 0) {
		starter_return(upfds, downfds,
			JOB_EXEC_FAIL2, &sjr);          /* exits */
	}

	if ((i = mom_set_limits(pjob, SET_LIMIT_SET)) != PBSE_NONE) {
		(void)sprintf(log_buffer, "Unable to set limits, err=%d", i);
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_ERR,
			pjob->ji_qs.ji_jobid, log_buffer);
		if (i == PBSE_RESCUNAV) {       /* resource temp unavailable */
			if (is_interactive)
				j = JOB_EXEC_FAIL2;
			else
				j = JOB_EXEC_RETRY;
		}
		else
			j = JOB_EXEC_FAIL2;
		starter_return(upfds, downfds, j, &sjr);        /* exits */
	}
	endpwent();

	if (set_credential(pjob, &shell, &argv) == -1) {
		starter_return(upfds, downfds,
			JOB_EXEC_FAIL2, &sjr);          /* exits */
	}

	/* NULL terminate the envp array, This is MUST DO       */
	*(vtable.v_envp + vtable.v_used) = (char *)0;

	/*
	 * Change working directory to User's Home.
	 * If in "sandbox=PRIVATE" mode, it is preferable to start in User's HOME
	 * in order to process user's "dot" files in the login shell,
	 * but if user's Home does not exist, start in PBS_JOBDIR.
	 *
	 * Note that even while job process is started in user's Home,
	 * when "sandbox" is "PRIVATE", "cd $PBS_JOBDIR" is prepended to the job script name,
	 * so job script is executed in $PBS_JOBDIR after "dot" files from user's Home are processed.
	 * See the code for the forked parent (about 700 lines above), look for the comment:
	 * "the parent side, still the main man, uhh that is MOM"
	 */
	if (chdir(pwdp->pw_dir) == -1) {
		log_event(PBSEVENT_JOB | PBSEVENT_SECURITY, PBS_EVENTCLASS_JOB,
			LOG_ERR, pjob->ji_qs.ji_jobid,
			"Could not chdir to Home directory");
		(void)fprintf(stderr, "Could not chdir to home directory\n");
		if ((pjob->ji_wattr[(int)JOB_ATR_keep].at_flags & ATR_VFLAG_SET) &&
		/* check if "qsub -k[oe]" was specified */
			((strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, 'o')) ||
			(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, 'e')))) {
			/* user Home is required for job output if "qsub -k[oe]" was specified */
			starter_return(upfds, downfds, JOB_EXEC_FAIL2, &sjr);
			return;
		} else if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			/* "sandbox=PRIVATE" mode is active, so job can be started in PBS_JOBDIR instead of user Home */
			if ((!pbs_jobdir) || (chdir(pbs_jobdir) == -1)) {
				log_event(PBSEVENT_JOB | PBSEVENT_SECURITY, PBS_EVENTCLASS_JOB,
					LOG_ERR, pjob->ji_qs.ji_jobid,
					"sandbox=PRIVATE mode: Could not chdir to job PBS_JOBDIR directory\n");
				starter_return(upfds, downfds, JOB_EXEC_FAIL2, &sjr);
			}
			/* an else case for O_WORKDIR should be added here */
		} else {
			/* nothing special specified, so job must be started in user Home  */
			starter_return(upfds, downfds, JOB_EXEC_FAIL2, &sjr);
			return;
		}
	}

	/* tell mom we are going */
	starter_return(upfds, downfds, JOB_EXEC_OK, &sjr);
	log_close(0);

	if ((pjob->ji_numnodes == 1) || nodemux ||
		((cpid = fork()) > 0)) {   /* parent does the shell */
		/* close sockets that child uses */
		(void)close(pjob->ji_stdout);
		(void)close(pjob->ji_stderr);

		execve(shell, argv, vtable.v_envp);
	}
	else if (cpid == 0) {           /* child does demux */
		char    *arg[2];
		char    *shellname;

		/* setup descriptors 3 and 4 */
		(void)dup2(pjob->ji_stdout, 3);
		if (pjob->ji_stdout > 3)
			close(pjob->ji_stdout);
		(void)dup2(pjob->ji_stderr, 4);
		if (pjob->ji_stderr > 4)
			close(pjob->ji_stderr);

		/* construct argv array */
		shell = pbs_conf.pbs_demux_path;
		shellname = strrchr(shell, '/');
		if (shellname)
			++shellname;    /* go past last '/' */
		else
			shellname = shell;
		arg[0] = shellname;
		arg[1] = (char *)0;

		execve(shell, arg, vtable.v_envp);
	}
	fprintf(stderr, "pbs_mom, exec of %s failed with error %d\n",
		shell, errno);
	exit(254);      /* should never, ever get here */
}

/**
 * @brief
 *	Start a process for a spawn request.  This will be different from
 * 	a job's initial shell task in that the environment will be specified
 * 	and no interactive code need be included.
 *
 * @param[in] ptask - pointer to task structure
 * @param[in] argv - argument list
 * @param[in] envp - pointer to environment variable list
 * @param[in] nodemux - false if the task process needs demux, true otherwise
 *
 * @return      int
 * @retval      PBSE_NONE (0) if success
 * @retval      PBSE_* on error.
 */
int
start_process(task *ptask, char **argv, char **envp, bool nodemux)
{
	job	*pjob = ptask->ti_job;
	int	ebsize;
	char	buf[MAXPATHLEN+2];
	pid_t	pid;
	int	pipes[2], kid_read, kid_write, parent_read, parent_write;
	int	pts;
	int	i, j;
	int	fd;
	u_long	ipaddr;
	struct	array_strings	*vstrs;
	struct  startjob_rtn sjr;
	attribute		*pattr;
	
	memset(&sjr, 0, sizeof(sjr));
	if (pipe(pipes) == -1)
		return PBSE_SYSTEM;
	if (pipes[1] < 3) {
		kid_write = fcntl(pipes[1], F_DUPFD, 3);
		(void)close(pipes[1]);
	}
	else
		kid_write = pipes[1];
	parent_read = pipes[0];

	if (pipe(pipes) == -1)
		return PBSE_SYSTEM;
	if (pipes[0] < 3) {
		kid_read = fcntl(pipes[0], F_DUPFD, 3);
		(void)close(pipes[0]);
	}
	else
		kid_read = pipes[0];
	parent_write = pipes[1];

	/*
	 ** Get ipaddr to Mother Superior.
	 */
	if (pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE)	/* I'm MS */
		ipaddr = htonl(localaddr);
	else {
		struct	sockaddr_in	*ap;

		/*
		 ** We always have a stream open to MS at node 0.
		 */
		i = pjob->ji_hosts[0].hn_stream;
		if ((ap = rpp_getaddr(i)) == NULL) {
			sprintf(log_buffer, "job %s has no stream to MS",
				pjob->ji_qs.ji_jobid);
			log_joberr(-1, __func__, log_buffer, pjob->ji_qs.ji_jobid);
			return PBSE_SYSTEM;
		}
		ipaddr = ap->sin_addr.s_addr;
	}

	/*
	 ** Begin a new process for the fledgling task.
	 */
	if ((pid = fork_me(-1)) == -1)
		return PBSE_SYSTEM;
	else if (pid != 0) {		/* parent */
		(void)close(kid_read);
		(void)close(kid_write);

		/* read sid */
		i = readpipe(parent_read, &sjr, sizeof(sjr));
		j = errno;
		(void)close(parent_read);
		if (i != sizeof(sjr)) {
			sprintf(log_buffer,
				"read of pipe for pid job %s got %d not %d",
				pjob->ji_qs.ji_jobid, i, (int)sizeof(sjr));
			log_err(j, __func__, log_buffer);
			(void)close(parent_write);
			return PBSE_SYSTEM;
		}
		(void)writepipe(parent_write, &sjr, sizeof(sjr));
		(void)close(parent_write);
		DBPRT(("%s: read start return %d %d\n", __func__,
			sjr.sj_code, sjr.sj_session))

		/*
		 ** Set the global id before exiting on error so any
		 ** information can be put into the job struct first.
		 */
		set_globid(pjob, &sjr);
		if (sjr.sj_code < 0) {
			(void)sprintf(log_buffer, "task not started, %s %s %d",
				(sjr.sj_code==JOB_EXEC_RETRY)?
				"Retry" : "Failure",
				argv[0],
				sjr.sj_code);
			log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB,
				LOG_NOTICE, pjob->ji_qs.ji_jobid, log_buffer);
			return PBSE_SYSTEM;
		}

		ptask->ti_qs.ti_sid = sjr.sj_session;
		ptask->ti_qs.ti_status = TI_STATE_RUNNING;
		(void)task_save(ptask);
		if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING) {
			pjob->ji_qs.ji_state = JOB_STATE_RUNNING;
			pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;
			job_save(pjob, SAVEJOB_QUICK);
		}
		(void)sprintf(log_buffer, "task started, %s", argv[0]);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
			pjob->ji_qs.ji_jobid, log_buffer);
		return PBSE_NONE;
	}

	/************************************************/
	/* The child process - will become the TASK	*/
	/************************************************/
	(void)close(lockfds);
	(void)close(parent_read);
	(void)close(parent_write);

	/*
	 * set up the Environmental Variables to be given to the job
	 */

	for (j=0, ebsize=0; envp[j]; j++)
		ebsize += strlen(envp[j]);
	vstrs = pjob->ji_wattr[(int)JOB_ATR_variables].at_val.at_arst;
	vtable.v_ensize = vstrs->as_usedptr + num_var_else + num_var_env +
		j + EXTRA_ENV_PTRS;
	vtable.v_used   = 0;
	vtable.v_envp = (char **)malloc(vtable.v_ensize * sizeof(char *));

	/* First variables from the local environment */
	for (j = 0; j < num_var_env; ++j)
		bld_env_variables(&vtable, environ[j], (char *)0);

	/* Next, the variables passed with the job.  They may   */
	/* be overwritten with new correct values for this job	*/

	for (j = 0; j < vstrs->as_usedptr; ++j)
		bld_env_variables(&vtable, vstrs->as_string[j], (char *)0);

	/* HOME */
	bld_env_variables(&vtable, variables_else[0],
		pjob->ji_grpcache->gc_homedir);

	/* PBS_JOBNAME */
	bld_env_variables(&vtable, variables_else[2],
		pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str);

	/* PBS_JOBID */
	bld_env_variables(&vtable, variables_else[3], pjob->ji_qs.ji_jobid);

	/* PBS_QUEUE */
	bld_env_variables(&vtable, variables_else[4],
		pjob->ji_wattr[(int)JOB_ATR_in_queue].at_val.at_str);

	/* PBS_JOBCOOKIE */
	bld_env_variables(&vtable, variables_else[7],
		pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str);

	/* PBS_NODENUM */
	sprintf(buf, "%d", pjob->ji_nodeid);
	bld_env_variables(&vtable, variables_else[8], buf);

	/* PBS_TASKNUM */
	sprintf(buf, "%u", ptask->ti_qs.ti_task);
	bld_env_variables(&vtable, variables_else[9], buf);

	/* PBS_MOMPORT */
	sprintf(buf, "%d", pbs_rm_port);
	bld_env_variables(&vtable, variables_else[10], buf);

	/* OMP_NUM_THREADS */
	sprintf(buf, "%d", pjob->ji_vnods[ptask->ti_qs.ti_myvnode].vn_cpus);
	bld_env_variables(&vtable, variables_else[12], buf);

	if (set_mach_vars(pjob, &vtable) != 0) {
		/* never reaches here */
	}
	umask(077);

	/* set Environment to reflect batch */
	bld_env_variables(&vtable, "PBS_ENVIRONMENT", "PBS_BATCH");
	bld_env_variables(&vtable, "ENVIRONMENT", "BATCH");

	for (i=0; envp[i]; i++)
		bld_env_variables(&vtable, envp[i], NULL);

	/* Add TMPDIR to environment */
	j = mktmpdir(pjob->ji_qs.ji_jobid,
		pjob->ji_qs.ji_un.ji_momt.ji_exuid,
		pjob->ji_qs.ji_un.ji_momt.ji_exgid,
		&vtable);
	if (j != 0) {
		starter_return(kid_write, kid_read, j, &sjr);
	}

	j = set_job(pjob, &sjr);
	if (j < 0) {
		if (j == -1) {
			/* set_job didn't leave message in log_buffer */
			(void)strcpy(log_buffer, "Unable to set task session");
		}
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_NOTICE,
			pjob->ji_qs.ji_jobid, log_buffer);
		if (j == -3)
			j = JOB_EXEC_FAIL2;
		else
			j = JOB_EXEC_RETRY;
		starter_return(kid_write, kid_read, j, &sjr);
	}
	ptask->ti_qs.ti_sid = sjr.sj_session;
	if ((i = mom_set_limits(pjob, SET_LIMIT_SET)) != PBSE_NONE) {
		(void)sprintf(log_buffer, "Unable to set limits, err=%d", i);
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_WARNING,
			pjob->ji_qs.ji_jobid, log_buffer);
		if (i == PBSE_RESCUNAV)		/* resource temp unavailable */
			j = JOB_EXEC_RETRY;
		else
			j = JOB_EXEC_FAIL2;
		starter_return(kid_write, kid_read, j, &sjr);
	}

	if (set_credential(pjob, NULL, &argv) == -1) {
		starter_return(kid_write, kid_read,
			JOB_EXEC_FAIL2, &sjr);		/* exits */
	}

	/* NULL terminate the envp array, This is MUST DO */
	*(vtable.v_envp + vtable.v_used) = (char *)0;

	/* change working directory to User's Home */
	if (chdir(pjob->ji_grpcache->gc_homedir) == -1) {
		log_event(PBSEVENT_JOB | PBSEVENT_SECURITY, PBS_EVENTCLASS_JOB,
			LOG_ERR, pjob->ji_qs.ji_jobid,
			"Could not chdir to Home directory");
		(void)fprintf(stderr, "Could not chdir to home directory\n");
		starter_return(kid_write, kid_read, JOB_EXEC_FAIL2, &sjr);
	}

	/*
	 ** Set up stdin.
	 */
	if ((fd = open("/dev/null", O_RDONLY)) == -1) {
		log_err(errno, __func__, "could not open devnull");
		(void)close(0);
	}
	else {
		(void)dup2(fd, 0);
		if (fd > 0)
			(void)close(fd);
	}

	pattr = &pjob->ji_wattr[(int)JOB_ATR_nodemux];
	/* If nodemux is not already set by the caller, check job's JOB_ATR_nodemux attribute. */
	if (!nodemux && (pattr->at_flags & ATR_VFLAG_SET))
		nodemux = (int)pattr->at_val.at_long;

	if (pjob->ji_numnodes > 1) {
		if (nodemux) {
			/*
			 ** Open /dev/null for stdout and stderr.
			 */
			if ((fd = open("/dev/null", O_RDONLY)) == -1) {
				log_err(errno, __func__, "could not open devnull");
				(void)close(1);
				(void)close(2);
			}
			else {
				if (fd != 1)
					(void)dup2(fd, 1);
				if (fd != 2)
					(void)dup2(fd, 2);
				if (fd > 2)
					(void)close(fd);
			}
		}
		else {
			/*
			 ** Open sockets to demux proc for stdout and stderr.
			 */
			if ((fd = open_demux(ipaddr, pjob->ji_stdout)) == -1)
				starter_return(kid_write, kid_read, JOB_EXEC_FAIL2, &sjr);
			(void)dup2(fd, 1);
			if (fd > 1)
				(void)close(fd);
			if ((fd = open_demux(ipaddr, pjob->ji_stderr)) == -1)
				starter_return(kid_write, kid_read, JOB_EXEC_FAIL2, &sjr);
			(void)dup2(fd, 2);
			if (fd > 2)
				(void)close(fd);

			(void)write(1, pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str,
				strlen(pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str));
			(void)write(2, pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str,
				strlen(pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str));
		}
	} else if ((pjob->ji_wattr[(int)JOB_ATR_interactive].
		at_flags&ATR_VFLAG_SET) &&
		(pjob->ji_wattr[(int)JOB_ATR_interactive].
		at_val.at_long > 0)) {
		/* interactive job, single node, write to pty */
		if ((pts = open_pty(pjob)) < 0) {
			log_err(errno, __func__, "cannot open slave");
			starter_return(kid_write, kid_read, JOB_EXEC_FAIL1, &sjr);
		}
		(void)dup2(pts, 1);
		(void)dup2(pts, 2);

	} else {
		/* normal batch job, single node, write straight to files */
		if (open_std_out_err(pjob) == -1) {
			starter_return(kid_write, kid_read,
				JOB_EXEC_FAIL1, &sjr);
		}
	}

	log_close(0);
	starter_return(kid_write, kid_read, JOB_EXEC_OK, &sjr);
	environ = vtable.v_envp;
	execvp(argv[0], argv);
	fprintf(stderr, "%s: %s\n", argv[0], strerror(errno));
	exit(254);
	return PBSE_SYSTEM;	/* not reached */
}

/**
 * @brief
 *      Forks a child process, with the parent process returning the child
 *      process id, while the child closes shuts down rpp, and closes
 *      network descriptors, and turns off alarm.
 *
 * @param[in]   conn    - connection file descriptor to NOT close in the child.
 * @note
 *      If 'conn' is the impossible -1, then ALL connection descriptors will
 *      be closed.
 *
 * @return      pid_t
 * @retval      child process id        Success
 *
 */
pid_t
fork_me(int conn)
{
	struct sigaction act;
	pid_t		 pid;

	fflush(stdout);
	fflush(stderr);

	pid = fork();
	if (pid == 0) {
		/* now the child */

		/* Turn off alarm if it should happen to be on */
		alarm(0);
		rpp_terminate();

		/* Reset signal actions for most to SIG_DFL */
		sigemptyset(&act.sa_mask);
		act.sa_flags   = 0;
		act.sa_handler = SIG_DFL;
		(void)sigaction(SIGCHLD, &act, (struct sigaction *)0);
#if defined(_CRAY) && !defined(__sv2)
		(void)sigaction(WJSIGNAL, &act, (struct sigaction *)0);
#endif	/* _CRAY */
		(void)sigaction(SIGHUP, &act, (struct sigaction *)0);
		(void)sigaction(SIGINT, &act, (struct sigaction *)0);
		(void)sigaction(SIGTERM, &act, (struct sigaction *)0);

		/* Reset signal mask */
		(void)sigprocmask(SIG_SETMASK, &act.sa_mask, NULL);

		(void)mom_close_poll();
		net_close(conn);	/* close all but for the current */
	} else if (pid < 0)
		log_err(errno, "fork_me", "fork failed");

	return (pid);
}

/**
 * @brief
 *      starter_return - return starter value,
 *      exit if negative
 *
 */
void
starter_return(int upfds, int downfds, int code, struct startjob_rtn *sjrtn)
{
	struct startjob_rtn ack;

	sjrtn->sj_code = code;
	(void)writepipe(upfds, sjrtn, sizeof(*sjrtn));
	(void)close(upfds);

	/* wait for acknowledgement */
	(void) readpipe(downfds, &ack, sizeof(ack));
	(void)close(downfds);
	if (code < 0) {
		exit(254);
	}
}

/**
 * @brief
 * 	std_file_name - generate the fully qualified path/name for a
 *	job standard stream
 *
 * @param[in]  pjob - pointer to job structure
 * @param[in]  which - identifies which file: StdOut, StdErr, or Chkpt.
 * @param[out] keeping - set true if file to reside in User's Home or sandbox, false if in spool.
 *
 * @return char * - pointer to path which is in a static array.
 *
 */
char *
std_file_name(job *pjob, enum job_file which, int *keeping)
{
	static char  path[MAXPATHLEN+1];
	char  key;
	int   len;
	char *pd;
	char *suffix;

	if ((pjob->ji_wattr[(int)JOB_ATR_interactive].at_flags&ATR_VFLAG_SET) &&
		(pjob->ji_wattr[(int)JOB_ATR_interactive].at_val.at_long > 0)) {

		/* interactive job, name of pty is in outpath */

		*keeping = 0;
		return (pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str);
	}

	switch (which) {
		case StdOut:
			key    = 'o';
			suffix = JOB_STDOUT_SUFFIX;
			break;

		case StdErr:
			key    = 'e';
			suffix = JOB_STDERR_SUFFIX;
			break;

		case Chkpt:
			key = '\001';	/* should never be found */
			suffix = JOB_CKPT_SUFFIX;
			break;

		default:
			break;
	}

	if (pjob->ji_grpcache == NULL)
		return ("");	/* needs to be non-NULL for figuring out homedir path; */

	/* Is file to be kept?, if so use default name in Home directory */

	if ((pjob->ji_wattr[(int)JOB_ATR_keep].at_flags & ATR_VFLAG_SET) &&
		(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, key))) {

		/* yes, it is to be kept */

		/* sandbox=private mode set the path to be the path to the */
		/* staging and execution directory                         */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
		} else {
			(void)strcpy(path, pjob->ji_grpcache->gc_homedir);
		}

		pd = strrchr(pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str, '/');
		if (pd == (char *)0) {
			pd = pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str;
			(void)strcat(path, "/");
		}

		(void)strcat(path, pd);		/* start with the job name */
		len = strlen(path);
		*(path + len++) = '.';          /* the dot        */
		*(path + len++) = key;		/* the letter     */
		pd = pjob->ji_qs.ji_jobid;      /* the seq_number */
		while (isdigit((int)*pd))
			*(path + len++) = *pd++;
		*(path + len) = '\0';
		if (pjob->ji_wattr[(int)JOB_ATR_array_index].at_flags & ATR_VFLAG_SET) {
			/* this is a sub job of an Array Job, append .index */
			(void)strcat(path, ".");
			(void)strcat(path, pjob->ji_wattr[(int)JOB_ATR_array_index].at_val.at_str);
		}
		*keeping = 1;
	} else {

		/* put into spool directory unless NO_SPOOL_OUTPUT is defined */

#ifdef NO_SPOOL_OUTPUT
		/* sandbox=PRIVATE mode puts output in job staging and execution directory */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags&ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[(int)JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
		} else {        /* force all output to user's HOME */
			(void)strcpy(path, pjob->ji_grpcache->gc_homedir);
		}
		(void)strcat(path, "/");
		*keeping = 1;
#else	/* NO_SPOOL_OUTPUT */
		/* sandbox=PRIVATE mode puts output in job staging and execution directory */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags&ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[(int)JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
			strcat(path, "/");
		} else {
			(void)strcpy(path, path_spool);
		}
		*keeping = 0;
#endif	/* NO_SPOOL_OUTPUT */
		if (*pjob->ji_qs.ji_fileprefix != '\0')
			(void)strcat(path, pjob->ji_qs.ji_fileprefix);
		else
			(void)strcat(path, pjob->ji_qs.ji_jobid);
		(void)strcat(path, suffix);
	}
	return (path);
}

/**
 * @brief
 *      Open (create) either standard output or standard error for the job.
 *
 * @param[in] pjob  - pointer to job structure
 * @param[in] which - which file to create, StdOut, StdErr, or Chkpt
 * @param[in] mode  - file open oflag (O_CREAT, O_WRONLY, ...)
 * @param[in] exgid - User's gid
 *
 * @return      int
 * @retval      fd      On success
 * @retval      -1      on failure
 *
 */
int
open_std_file(job *pjob, enum job_file which, int mode, gid_t exgid)
{
	int   fds;
	int   keeping;
	char *path;

	path = std_file_name(pjob, which, &keeping);
	if (keeping) {
		/* in user's home,  may be NFS mounted, must create as user */

#if defined(HAVE_SETEUID) && defined(HAVE_SETEGID)
		/* most systems */
		if ((setegid(exgid) == -1) ||
			(seteuid(pjob->ji_grpcache->gc_uid) == -1))
			return -1;
		fds = open(path, mode, 0666);
		(void)seteuid(0);
		(void)setegid(pbsgroup);
#elif defined(HAVE_SETRESUID) && defined(HAVE_SETRESGID)
		/* HPUX and the like */
		if ((setresgid(-1, exgid, -1) == -1) ||
			(setresuid(-1, pjob->ji_grpcache->gc_uid, -1) == -1))
			return -1;
		fds = open(path, mode, 0666);
		(void)setresuid(-1, 0, -1);
		(void)setresgid(-1, pbsgroup, -1);
#else	/* Neither */
		Crash and Burn - need seteuid/setegid   or need setresuid/setresgid
#endif	/* HAVE_SETRESUID */
	} else {
		fds = open(path, mode, 0666);
		if (fds >= 0) {
			/* change file uid/gid to execution user of job  */
			(void)fchown(fds, pjob->ji_qs.ji_un.ji_momt.ji_exuid, exgid);
		}
	}
	return (fds);
}

/**
 * @brief
 *      find_env_slot - find if the environment variable is already in the table,
 *      If so, replace the existing one with the new one.
 *
 * @param[in] ptbl - pointer to var_table which holds environment variable for job
 * @param[in] pstr - new environment variable
 *
 * @return      int
 * @retval      !(-1)   success
 * @retval      -1      Failure
 *
 */

static int
find_env_slot(struct var_table *ptbl, char *pstr)
{
	int	 i;
	int	 len = 1;	/* one extra for '=' */

	if (pstr == NULL)
		return (-1);
	for (i=0; (*(pstr+i) != '=') && (*(pstr+i) != '\0'); ++i)
		++len;

	for (i=0; i<ptbl->v_used; ++i) {
		if (strncmp(ptbl->v_envp[i], pstr, len) == 0)
			return (i);
	}
	return (-1);
}

/**
 * @brief
 *	bld_env_variables - Add an entry to the table that defines the environment variables for a job.
 * @par
 * 	Note that this function returns void. It gives the caller no indication
 * 	whether the operation failed, which it could. In the case where the
 * 	operation does fail, the variable will not be added to the table and
 * 	will not be present in the job's environment. The caller would have
 * 	to check the table upon return of this function to confirm the
 * 	variable was added/updated correctly.
 *
 * @param[in] vtable - variable table
 * @param[in] name - variable name alone or a "name=value" string
 * @param[in] value - variable value or NULL if name contains "name=value"
 *
 * @return - None
 */
void
bld_env_variables(struct var_table *vtable, char *name, char *value)
{
	int     amt;
	int     i;
	char	*block;

	if ((vtable == NULL) || (name == NULL))
		return;

	if (value == NULL) {
		/* name must contain '=' */
		if (strchr(name, (int) '=') == NULL)
			return;
	} else {
		/* name may not contain '=' */
		if (strchr(name, (int) '=') != NULL)
			return;
	}

	amt = strlen(name) + 1;			/* plus 1 for terminator */
	if (value)
		amt += strlen(value) + 1;	/* plus 1 for "=" */

	block = malloc(amt);
	if (block == NULL)			/* no room for string */
		return;

	(void)strcpy(block, name);
	if (value) {
		(void)strcat(block, "=");
		(void)strcat(block, value);
	}

	if ((i = find_env_slot(vtable, block)) < 0) {
		/*
		 ** See if last available slot is used.
		 ** This needs to be one less than v_ensize
		 ** to make sure there is a NULL termination.
		 */
		if (vtable->v_used+1 == vtable->v_ensize) {
			int	newsize = vtable->v_ensize * 2;
			char	**tt = realloc(vtable->v_envp,
				newsize*sizeof(char *));

			if (tt == NULL)
				return;		/* no room for pointer */
			vtable->v_ensize = newsize;
			vtable->v_envp = tt;
		}

		*(vtable->v_envp + vtable->v_used++) = block;
		*(vtable->v_envp + vtable->v_used) = NULL;
	} else {
		/* free old value */
		free(*(vtable->v_envp + i));
		*(vtable->v_envp + i) = block;
	}
}

/**
 * @brief
 * 	catchinter = catch death of writer child and/or shell child of interactive
 *	When one dies, kill off the other; there is no mercy in this family.
 *
 * @param[in] sig - signal number
 *
 */
static void
catchinter(int sig)
{
	int   status;
	pid_t pid;

	pid = waitpid(-1, &status, WNOHANG);
	if (pid == 0)
		return;
	if (pid == writerpid) {
		kill(shellpid, SIGKILL);
		(void)wait(&status);
	} else {
		kill(writerpid, SIGKILL);
		(void)wait(&status);
	}
	mom_reader_go = 0;
}

#endif	/* WIN32/UNIX ---------------------------------------------------- */

/**
 * @brief
 *      Free the ji_hosts and ji_vnods arrays for a job.  If any events are
 *      attached to an array element, free them as well.
 *
 * @param[in] pj - job pointer
 *
 * @return Void
 *
 */
void
nodes_free(job *pj)
{
	hnodent		*np;
	vmpiprocs       *vp;

	if (pj->ji_vnods) {
		for (vp=pj->ji_vnods; vp->vn_node != TM_ERROR_NODE; vp++) {
			if (vp->vn_hname)
				free(vp->vn_hname);
			if (vp->vn_vname)
				free(vp->vn_vname);
		}
		(void)free(pj->ji_vnods);
		pj->ji_vnods = NULL;
	}

	if (pj->ji_vnods0) {
		for (vp=pj->ji_vnods0; vp->vn_node != TM_ERROR_NODE; vp++) {
			if (vp->vn_hname)
				free(vp->vn_hname);
			if (vp->vn_vname)
				free(vp->vn_vname);
		}
		(void)free(pj->ji_vnods0);
		pj->ji_vnods0 = NULL;
	}

	if (pj->ji_hosts) {
		for (np=pj->ji_hosts; np->hn_node != TM_ERROR_NODE; np++) {
			eventent	*ep = (eventent *)GET_NEXT(np->hn_events);

			if (np->hn_host)
				free(np->hn_host);
			if (np->hn_vlist)
				free(np->hn_vlist);

			/* don't close stream incase another job uses it */
			while (ep) {

				if (ep->ee_argv)
					arrayfree(ep->ee_argv);
				if (ep->ee_envp)
					arrayfree(ep->ee_envp);
				delete_link(&ep->ee_next);
				free(ep);
				ep = (eventent *)GET_NEXT(np->hn_events);
			}
			/*
			 ** Here we free any dependent structure(s) from hn_setup.
			 */
			if (job_free_node != NULL)
				job_free_node(pj, np);
		}
		free(pj->ji_hosts);
		pj->ji_hosts = NULL;
	}
}

/**
 * @brief
 *	job_nodes - process scedselect and exec_vnode to build mapping between
 *	chunks and allocated nodes/resources.
 *
 * @par Functionality:
 *	Loops through schedselect attribute and concurrently exec_vnode and
 *	exec_host attributes creating two arrays of structures:
 *	    hnodent - one per Mom regardless of the number of vnodes
 *		allocated from that Mom.  For the local Mom's entry, indexed
 *		by pjob->ji_nodeid, the hnodent will also contain an sub-array
 *		of host_vlist_t with one entry per vnode allocated on this host.
 *		This sub-array's length is given by hn_vlnum.
 *	    vmiprocs - one pre task/mpi process to be created;  there is one
 *		line per entry written into PBS_NODEFILE by Mom
 *	Both of the hnodent and vmpiprocs arrays are terminated by an entry
 *	where the id (hn_node or vn_node) is set to TM_ERROR_NODE.
 *  Additionally this function also determines the ji_nodeid of the job
 *	by matching the mom's name and port with the exechost list.
 *
 * @param[in]	pjob - pointer to job structure for job to be run
 * @param[out]	mynp - pointer to hnodent structure to be filled with the
 *                     hnodent for the node matching the current mom:port
 * @return	int
 * @retval	PBSE_NONE (0) if success
 * @retval	PBSE_* on error.
 *
 * @par Side Effects:
 *	pjob->ji_vnods and  pjob->ji_hosts are set, arrays in the heap
 *
 * @par MT-safe: likely no
 *
 */

int
job_nodes_inner(struct job *pjob, hnodent **mynp)
{
	char	*execvnode;
	char	*schedselect;
	int	 i, j, k, m = 0, n;
	hnodent *hp = NULL;
	int	 hpn;
	int	 momindex;
	char	*mname;
	char	 natvnodename[PBS_MAXNODENAME+1];
	char	 momname[PBS_MAXNODENAME+1];
	char     momport[10] = {0};
	int	 nmoms;
	int	 nthreads;
	int	 numprocs;
	int	 found_cpus0;
	vmpiprocs *vmp;
	momvmap_t *pmm;
	mominfo_t *pmom;
	momvmap_t *pnat = NULL;
	char	*peh;
	int	 port;
	int	 nprocs;
	int	 n_chunks;
	int	 procindex;
	int	 procindex0;
	int	 rc;
	long long sz;
	char	*tpc;
	resc_limit have;
	resc_limit need;

	/* variables used in parsing the "exec_vnode" string */
	int	 stop_on_paren;
	char	*pndspec;
	char	*elast;
	int	 enelma;
	char	*nodep;
	static int	       ebuf_len = 0;
	static char	      *ebuf = NULL;
	static int	       enelmt = 0;
	static key_value_pair *enkv = NULL;

	/* variables used in parsing the "schedselect" string */
	char	*psubspec;
	char	*slast;
	int	 snc;
	int	 snelma;
	static int	       sbuf_len = 0;
	static char	      *sbuf = NULL;
	static int	       snelmt = 0;
	static key_value_pair *skv = NULL;

	if (pjob == NULL)
		return (PBSE_INTERNAL);
	if (!(pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_flags & ATR_VFLAG_SET))
		return (PBSE_INTERNAL);
	if (!(pjob->ji_wattr[(int)JOB_ATR_SchedSelect].at_flags & ATR_VFLAG_SET))
		return (PBSE_INTERNAL);

	/* free what might have been done before if job is restarted */
	nodes_free(pjob);

	execvnode = pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_val.at_str;
	schedselect = pjob->ji_wattr[(int)JOB_ATR_SchedSelect].at_val.at_str;
	if (pjob->ji_wattr[(int)JOB_ATR_exec_host2].at_val.at_str != NULL) {
		/* Mom got information from new server */
		enable_exechost2 = 1;
		peh = pjob->ji_wattr[(int)JOB_ATR_exec_host2].at_val.at_str;
	} else {
		peh = pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str;
	}
	if (peh == NULL)
		return (PBSE_INTERNAL);

	/* make sure parsing buffers are long enought */
	if ((i = strlen(execvnode)) >= ebuf_len) {
		tpc = (char *)realloc(ebuf, i+100);
		if (tpc == NULL)
			return (PBSE_SYSTEM);
		ebuf = tpc;
		ebuf_len = i + 100;
	}
	if ((i = strlen(schedselect)) >= sbuf_len) {
		tpc = (char *)realloc(sbuf, i+100);
		if (tpc == NULL)
			return (PBSE_SYSTEM);
		sbuf = tpc;
		sbuf_len = i + 100;
	}

	strcpy(sbuf, schedselect);

	/* First, go parse schedselect and count up number of chunks and */
	/* total number of mpiprocs;   assuming one Mom per chunk and    */
	/* one mpiproc structure per mpiproc, this is used to obtain a   */
	/* maxmimun number of each for allocating the array              */

	nmoms  = 0;	/* num of mom (struct hnodent) entries needed    */
	nprocs = 0;	/* num of vmpiproc entries needed                */
	n_chunks = 0;	/* number of chunks */

	psubspec = parse_plus_spec_r(sbuf, &slast, &hpn);
	/* hpn set to 1 if open paren found, -1 if close paren found, or */
	/* 0 if neither or both found					 */

	while (psubspec) {
		DBPRT(("\tsubspec: %s\n", psubspec))
		rc = parse_chunk_r(psubspec, &snc, &snelma, &snelmt, &skv, NULL);
		/* snc is the number (repeat factor) of chunks */
		if (rc != 0)
			return (rc);

		nmoms += snc;		/* num of Moms, one per chunk */
		k = 1;			/* default number of mpiprocs */
		for (j=0; j<snelma; ++j) {
			if (strcmp(skv[j].kv_keyw, "mpiprocs") == 0) {
				k= atol(skv[j].kv_val);
				break;
			}
		}
		nprocs += snc * k;	/* mpiproces * num of chunks */
		n_chunks += snc;
		psubspec = parse_plus_spec_r(slast, &slast, &hpn);
	}

	DBPRT(("- allocating %d hosts and %d procs\n", nmoms, nprocs))
	pjob->ji_hosts = (hnodent *)calloc(nmoms+1, sizeof(hnodent));
	pjob->ji_vnods = (vmpiprocs *)calloc(nprocs+1, sizeof(vmpiprocs));
	pjob->ji_vnods0 = (vmpiprocs *)calloc(n_chunks+1, sizeof(vmpiprocs));

	if ((pjob->ji_hosts == NULL) || (pjob->ji_vnods == NULL) ||
		(pjob->ji_vnods0 == NULL)) {
		log_err(errno, "job_nodes" , "calloc failed");
		return (PBSE_SYSTEM);
	}

	for (i=0; i <= nmoms; ++i) {
		pjob->ji_hosts[i].hn_node = TM_ERROR_NODE;
		CLEAR_HEAD(pjob->ji_hosts[i].hn_events);
	}
	for (i=0; i <= nprocs; ++i)
		pjob->ji_vnods[i].vn_node = TM_ERROR_NODE;

	for (i=0; i <= n_chunks; ++i) {
		pjob->ji_vnods0[i].vn_node = TM_ERROR_NODE;
	}	

	/* Now parse schedselect and exec_vnode at same time to map mpiprocs */
	/* onto the corresponding Mom and sum up the resources allocated     */
	/* from each Mom						     */

	strcpy(ebuf, execvnode);
	strcpy(sbuf, schedselect);


	momindex  = 0;
	procindex = 0;
	procindex0 = 0;

	elast = ebuf;

	/*
	 * Next we parse the select spec to look at the next chunk that was
	 * requested by the user.  For each chunk we
	 * 1. parse the subspecs from the exec_vnode that were allocated for
	 *    that chunk.  Then
	 *    a. for the first vnode, get the Mom/host and setup the hnodent
	 *    b. for my hnodent, for each vnode, add a host_vlist entry to
	 *       the hnodent entry
	 * 2. setup the number of "mpiprocs" (from the chunk) vmpiprocs
	 */

	/* (1) parse chunk from select spec */
	psubspec = parse_plus_spec_r(sbuf, &slast, &hpn);
	while (psubspec) {
		DBPRT(("\tsubspec: %s\n", psubspec))
		nthreads = -1;
		numprocs = -1;
		found_cpus0 = 0;
		rc = parse_chunk_r(psubspec, &snc, &snelma, &snelmt, &skv, NULL);
		/* snc = number of chunks */
		if (rc != 0) {
			return (rc);
		}

		for (i=0; i<snc; ++i) {	   /* for each chunk in schedselect.. */

			/* clear "need" counts */
			memset(&need, 0, sizeof(need));

			/* clear "have" counts */
			memset(&have, 0, sizeof(have));

			/* figure out what is "need"ed */
			for (j=0; j<snelma; ++j) {
				if (strcmp(skv[j].kv_keyw, "ncpus") == 0)
					need.rl_ncpus= atol(skv[j].kv_val);				
				else if (strcmp(skv[j].kv_keyw, "mem") == 0)
					need.rl_mem= to_kbsize(skv[j].kv_val);
				else if (strcmp(skv[j].kv_keyw, "vmem") == 0)
					need.rl_vmem = to_kbsize(skv[j].kv_val);
				else if (strcmp(skv[j].kv_keyw, "mpiprocs") == 0)
					numprocs = atol(skv[j].kv_val);
				else if (strcmp(skv[j].kv_keyw, "ompthreads") == 0)
					nthreads = atol(skv[j].kv_val);
			}
			if (nthreads == -1)
				nthreads = need.rl_ncpus;

			if (numprocs == -1) {
				if (need.rl_ncpus == 0) {
					numprocs = 0;
					found_cpus0 = 1;
				} else {
					numprocs = 1;
				}
			}

			DBPRT(("\tchunk: %d, need %d ncpus and %lu mem\n", i,
				need.rl_ncpus, (unsigned long) need.rl_mem))

			/*
			 * The "natural" vnode for the Mom who is managing
			 * this chunk of resources can be determined by the
			 * corresponding entry in exec_host.  We have to know which
			 * Mom in case of multiple-Moms for the allocated vnodes
			 */
			n = 0;
			if (enable_exechost2 == 0) {
				while ((*peh != '/') && (*peh != '\0') &&
					(n < PBS_MAXNODENAME)) {
					natvnodename[n++] = *peh++;
				}
				natvnodename[n] = '\0';
			} else {
				momport[0] = '\0';
				while ((*peh != ':') && (*peh != '/') && (*peh != '\0') &&
					(n < PBS_MAXNODENAME)) {
					momname[n++] = *peh++;
				}
				momname[n] = '\0';
				/* check if peh is colon, if so parse out port */
				n = 0;
				if (*peh == ':') {
					peh++; /* skip first ':' character to get port number */
					while ((*peh != '/') && (*peh != '\0') && (n < sizeof(momport)))
						momport[n++] = *peh++;
				}
				momport[n] = '\0';
			}

			/* advance past the "+" to the next host */
			while (*peh != '\0') {
				if (*peh++ == '+')
					break;
			}

			if (enable_exechost2 == 0) {
				pnat = find_vmap_entry(natvnodename);
				if (pnat != NULL) {
					/* found a map entry */
					mname = pnat->mvm_mom->mi_host;
					port = pnat->mvm_mom->mi_port + 1; /* RM port */
				} else {
					/* no map entry, assume same vnode name is */
					/* the host name and the port is standard  */
					mname = natvnodename;
					port  = pbs_mom_port + 1; /* RM port */
				}
			} else {
				mname = momname;
				if (strlen(momport) > 0) {
					port = atol(momport) + 1;
				} else {
					port = pbs_mom_port + 1;  /* RM port */
				}
			}

			/*
			 * for the natural vnode in a set that satisfies a chunk,
			 * find see if we have a hnodent entry for the parent Mom,
			 * if not add an entry
			 */

			/* see if we already have this mom */

			for (j=0; j < momindex; ++j) {
				if ((strcmp(mname, pjob->ji_hosts[j].hn_host)==0)
					&& (port == pjob->ji_hosts[j].hn_port))
					break;
			}
			hp = &pjob->ji_hosts[j];
			if ((hp != NULL) && (j == momindex)) {
				/* need to add entry */
				hp->hn_node = momindex++;
				hp->hn_host   = strdup(mname);
				if (hp->hn_host == NULL)
					return (PBSE_SYSTEM);
				hp->hn_port   = port;
				hp->hn_stream = -1;
				hp->hn_sister = SISTER_OKAY;
				hp->hn_nprocs = 0;
				hp->hn_vlnum  = 0;
				hp->hn_vlist  = (host_vlist_t *)0;
				memset(&hp->hn_nrlimit, 0, sizeof(resc_limit));
				CLEAR_HEAD(hp->hn_events);
				/* mark next slot as the (current) end */
				pjob->ji_hosts[momindex].hn_node =
					TM_ERROR_NODE;

				if (strcmp(hp->hn_host, mom_host) == 0 && hp->hn_port == pbs_rm_port) {
						pjob->ji_nodeid = hp->hn_node;
						if (mynp) {
							*mynp = hp;
						}
				}
			}

			/* now parse exec_vnode to match up alloc-ed with needed */

			stop_on_paren = 0;

			while ((pndspec = parse_plus_spec_r(elast, &elast, &hpn)) !=
				NULL) {
				int       vnncpus = 0;
				long long ndmem   = 0;

				if (hpn > 0)		/* found open paren '(' */
					stop_on_paren = 1;

				rc = parse_node_resc_r(pndspec, &nodep, &enelma,
					&enelmt, &enkv);

				/* if no resources specified, skip it */
				if (enelma == 0) {
					stop_on_paren = 0;
					DBPRT(("\t\tignoring vnode %s without resources\n", nodep))
					continue;       /* check next piece */
				}

				/* nodep = vnode name */
				if (rc != 0) {
					return (rc);
				}
				DBPRT(("\t\tusing vnode %s\n", nodep))

				/* find the Mom who manages the vnode */
				pmm = (momvmap_t *)find_vmap_entry(nodep);
				if (pmm == NULL) {
					/* Did not find a vmap entry for this vnode */
					/* assume it is host and add it w/ std port */
					if (enable_exechost2) {
						/* In case mom connected with newer server  */
						pmom = create_mom_entry(mname, port - 1);
					} else {
						pmom = create_mom_entry(nodep, pbs_mom_port);
					}
					if (pmom == NULL)
						return PBSE_SYSTEM;
					if (enable_exechost2) {
						pmm = create_mommap_entry(nodep, mname, pmom, 0);
					} else {
						pmm = create_mommap_entry(nodep, NULL, pmom, 0);
					}
					if (pmm == NULL) {
						delete_mom_entry(pmom);
						return PBSE_SYSTEM;
					}
					log_event(PBSEVENT_DEBUG3, PBS_EVENTCLASS_NODE,
						LOG_DEBUG, nodep,
						"implicitly added host to vmap");
				}

				/* for the allocated resc, add to hnodent resc_limit */
				/* which is used for limit enforcement while running */

				for (j=0; j<enelma; ++j) {
					if (strcmp(enkv[j].kv_keyw, "ncpus") == 0) {
						vnncpus = atoi(enkv[j].kv_val);
						have.rl_ncpus += vnncpus;
						hp->hn_nrlimit.rl_ncpus += vnncpus;
					} else if (strcmp(enkv[j].kv_keyw, "mem") == 0) {
						ndmem = to_kbsize(enkv[j].kv_val);
						have.rl_mem += ndmem;
						hp->hn_nrlimit.rl_mem += ndmem;
					} else if (strcmp(enkv[j].kv_keyw, "vmem") == 0) {
						sz = to_kbsize(enkv[j].kv_val);
						have.rl_vmem += sz;
						hp->hn_nrlimit.rl_vmem += sz;
					} else if (strcmp(enkv[j].kv_keyw, "ssinodes")==0) {
						hp->hn_nrlimit.rl_ssi  += atoi(enkv[j].kv_val);
					}
				}

				/* (1b)if this mom is me, add vnode to  host_vlist */
				if (hp->hn_node == pjob->ji_nodeid) {
					host_vlist_t *phv;
					phv = (host_vlist_t *)realloc(hp->hn_vlist,
						(hp->hn_vlnum+1) * sizeof(host_vlist_t));
					if (phv == NULL) {
						return (PBSE_INTERNAL);
					}
					hp->hn_vlist = phv;
					strncpy(phv[hp->hn_vlnum].hv_vname, nodep,
						PBS_MAXNODENAME);
					phv[hp->hn_vlnum].hv_ncpus = vnncpus;
					phv[hp->hn_vlnum].hv_mem   = ndmem;
					hp->hn_vlnum++;
				}
				if (stop_on_paren  == 0)
					break;
				else if (hpn < 0)
					break;
			}
			hp->hn_nprocs += numprocs;

			/* (2) setup the number of vmpiprocs entries based */
			/* on the number of procs, numprocs, in this chunk */

			for (k=0; k < numprocs; ++k) {
				vmp = &pjob->ji_vnods[procindex];
				vmp->vn_node = procindex++;
				vmp->vn_host = hp;
				if (pmm->mvm_hostn) {
					/* copy the true host name */
					vmp->vn_hname = strdup(pmm->mvm_hostn);
					if (vmp->vn_hname == NULL)
						return (PBSE_SYSTEM);
				} else {
					/* set null and we will use the Mom name */
					vmp->vn_hname = NULL;
				}
				if ((vmp->vn_vname = strdup(pmm->mvm_name)) == NULL) {
					if (vmp->vn_hname)
						free(vmp->vn_hname);
					return (PBSE_SYSTEM);
				}
				vmp->vn_cpus  = have.rl_ncpus;
				vmp->vn_mem  = have.rl_mem;
				vmp->vn_vmem  = have.rl_vmem;
				vmp->vn_mpiprocs  = numprocs;
				vmp->vn_threads = nthreads;

				/* mark next entry as the (current) end */
				pjob->ji_vnods[procindex].vn_node = TM_ERROR_NODE;
			}

			/* track zero cpu-assigned vnodes in this chunk. */
			if (found_cpus0 && (pjob->ji_vnods0 != NULL)) {
				vmp = &pjob->ji_vnods0[procindex0];
				vmp->vn_node = procindex0++;
				vmp->vn_host = hp;
				if (pmm->mvm_hostn) {
					/* copy the true host name */
					vmp->vn_hname = strdup(pmm->mvm_hostn);
					if (vmp->vn_hname == NULL)
						return (PBSE_SYSTEM);
				} else {
					/* set null and we will use the Mom name */
					vmp->vn_hname = NULL;
				}
				/* track only what's needed by hooks */
				vmp->vn_vname = strdup(pmm->mvm_name);
				if (vmp->vn_vname == NULL) {
					if (vmp->vn_hname != NULL) {
						free(vmp->vn_hname);
						vmp->vn_hname = NULL;
					}
					return (PBSE_SYSTEM);
				}
				vmp->vn_cpus  = have.rl_ncpus;
				vmp->vn_mem  = have.rl_mem;
				/* mark next entry as the (current) end */
				pjob->ji_vnods0[procindex0].vn_node = TM_ERROR_NODE;
			}
		}

		/* do next section of schedselect */
		psubspec = parse_plus_spec_r(slast, &slast, &hpn);
	}

	pjob->ji_numnodes = momindex;
	pjob->ji_numvnod  = procindex;
	pjob->ji_numvnod0  = procindex0;

	return (0);
}

/**
 * @brief
 * 	wrapper function that calls job_nodes_inner with a NULL parameter
 * 	for the "mynodeid" parameter
 *
 * @param[in] pjob - job pointer
 */
int
job_nodes(struct job *pjob)
{
	return job_nodes_inner(pjob, NULL);
}

#define	NUMRAND	4

/**
 * @brief
 *      start_exec() - start execution of a job
 *
 * @param[in] pjob - job pointer
 *
 * @return      Void
 *
 */
void
start_exec(job *pjob)
{
	eventent	        *ep = NULL;
	int		        com, i, nodenum;
#ifndef WIN32
	int		        socks[2];
	int                     len;
	struct	sockaddr_in	saddr;
#endif
	hnodent		        *np = NULL;
	attribute	        *pattr = NULL;
	pbs_list_head	        phead;
	int		        nodemux = 0;
	int			mtfd = -1;

	/* make sure we have an open rpp stream back to the server */

	if (server_stream == -1)
		send_restart();

	/* The following may not be needed for Windows! */
	if (pjob->ji_mompost) {         /* fail until activity is done */
		log_err(-1, __func__, "waiting for worktask completion");
		exec_bail(pjob, JOB_EXEC_RETRY, NULL);
		return;
	}

	/* make sure we have a cookie for the job */

	if (!(pjob->ji_wattr[(int)JOB_ATR_Cookie].at_flags & ATR_VFLAG_SET)) {
		char			*tt;
		int			i;

		tt = pjob->ji_wattr[(int)JOB_ATR_Cookie].at_val.at_str =
			malloc(NUMRAND*2*sizeof(long) + 1);
		if (tt == NULL) {
			return;
		}

		pjob->ji_wattr[(int)JOB_ATR_Cookie].at_flags |=ATR_VFLAG_SET;

		for (i=0; i<NUMRAND; i++)
			sprintf(&tt[i], "%X", 0x0F & rand());
		DBPRT(("===== COOKIE %s\n", tt))
	}

	if ((i = job_nodes(pjob)) != 0) {
		sprintf(log_buffer, "job_nodes failed with error %d", i);
		log_event(PBSEVENT_ERROR, PBS_EVENTCLASS_JOB, LOG_NOTICE,
			pjob->ji_qs.ji_jobid, log_buffer);
		nodes_free(pjob);
		exec_bail(pjob, JOB_EXEC_RETRY, NULL);
		return;
	}
	pjob->ji_nodeid = 0;		/* I'm MS */
	nodenum = pjob->ji_numnodes;

	if (nodenum > 1) {

		pjob->ji_resources = (noderes *)calloc(nodenum-1,
			sizeof(noderes));
		assert(pjob->ji_resources != NULL);
		pjob->ji_numrescs = nodenum-1;
		CLEAR_HEAD(phead);
		pattr = pjob->ji_wattr;
		for (i=0; i < (int)JOB_ATR_LAST; i++) {
			(void)(job_attr_def+i)->at_encode(pattr+i, &phead,
				(job_attr_def+i)->at_name, (char *)0,
				ATR_ENCODE_MOM, NULL);
		}
		attrl_fixlink(&phead);
		/*
		 **		Open streams to the sisterhood.
		 */
		if (pbs_conf.pbs_use_mcast == 1) {
			/* open the tpp mcast channel here */
			if ((mtfd = tpp_mcast_open()) == -1) {
				sprintf(log_buffer, "mcast open failed");
				log_err(errno, __func__, log_buffer);
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				return;
			}
		}

		for (i=1; i<nodenum; i++) {
			np = &pjob->ji_hosts[i];

			np->hn_stream = rpp_open(np->hn_host, np->hn_port);
			if (np->hn_stream < 0) {
				sprintf(log_buffer, "rpp_open failed on %s:%d",
					np->hn_host, np->hn_port);
				log_err(errno, __func__, log_buffer);
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				return;
			}
			if (pbs_conf.pbs_use_mcast == 1) {
				/* add each of the rpp streams to the tpp mcast channel */
				if ((tpp_mcast_add_strm(mtfd, np->hn_stream)) == -1) {
					rpp_close(np->hn_stream);
					np->hn_stream = -1;
					tpp_mcast_close(mtfd);
					sprintf(log_buffer, "mcast add failed");
					log_err(errno, __func__, log_buffer);
					exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
					return;
				}
			}
		}

		pattr = &pjob->ji_wattr[(int)JOB_ATR_nodemux];
		if (pattr->at_flags & ATR_VFLAG_SET)
			nodemux = (int)pattr->at_val.at_long;
#ifndef WIN32
		if (nodemux) {
#endif
			pjob->ji_ports[0] = -1;
			pjob->ji_ports[1] = -1;
			pjob->ji_stdout = -1;
			pjob->ji_stderr = -1;
#ifndef WIN32
		} else {
			/*
			 **			Open two sockets for use by demux program later.
			 */
			for (i=0; i<2; i++)
				socks[i] = -1;
			for (i=0; i<2; i++) {

				if ((socks[i] = socket(AF_INET,
					SOCK_STREAM, 0)) == -1)
					break;

				memset(&saddr, '\0', sizeof(saddr));
				saddr.sin_addr.s_addr = INADDR_ANY;
				saddr.sin_family = AF_INET;
				if (bind(socks[i], (struct sockaddr *)&saddr,
					sizeof(saddr)) == -1)
					break;
				len = sizeof(saddr);
				if (getsockname(socks[i],
					(struct sockaddr *)&saddr,
					&len) == -1)
					break;
				pjob->ji_ports[i] = (int)ntohs(saddr.sin_port);
			}
			if (i < 2) {
				log_err(errno, __func__, "stdout/err socket");
				for (i=0; i<2; i++) {
					if (socks[i] != -1)
						close(socks[i]);
				}
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				return;
			}
			pjob->ji_stdout = socks[0];
			pjob->ji_stderr = socks[1];

		}
#endif

		/*
		 **		Send out a JOIN_JOB/RESTART message to all the MOM's in
		 **		the sisterhood.
		 */
		if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_CHKPT) ||
			(pjob->ji_qs.ji_svrflags & JOB_SVFLG_ChkptMig)) {
			com = IM_RESTART;
			pjob->ji_mompost = post_restart;

			if ((i = local_restart(pjob, NULL)) != 0) {
				post_restart(pjob, i);
				exec_bail(pjob, (i == PBSE_CKPBSY) ?
					JOB_EXEC_RETRY : JOB_EXEC_FAIL2, NULL);
				return;
			}
		}
		else

			com = IM_JOIN_JOB;

		for (i=1; i<nodenum; i++) {
			np = &pjob->ji_hosts[i];

			if (i == 1)
				ep = event_alloc(pjob, com, -1, np,
					TM_NULL_EVENT, TM_NULL_TASK);
			else
				ep = event_dup(ep, pjob, np);

			if (ep == NULL) {
				exec_bail(pjob, JOB_EXEC_FAIL1, NULL);
				return;
			}

			if (pbs_conf.pbs_use_mcast == 0)
				send_join_job_restart(com, ep, i, pjob, &phead);
		}

		if (pbs_conf.pbs_use_mcast == 1) {
			send_join_job_restart_mcast(mtfd, com, ep, i, pjob, &phead);
			tpp_mcast_close(mtfd);
		}

		free_attrlist(&phead);
	} else {		/* no sisters */
		pjob->ji_ports[0] = -1;
		pjob->ji_ports[1] = -1;
		pjob->ji_stdout = -1;
		pjob->ji_stderr = -1;

		/*
		 ** This is a single node job but we need to do any
		 ** extra setup provided by job_join_extra for local MS.
		 */
		if (job_join_extra != NULL) {
			if (job_join_extra(pjob, &pjob->ji_hosts[0]) != 0) {
				exec_bail(pjob, JOB_EXEC_RETRY, NULL);
				return;
			}
		}

		finish_exec(pjob);
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO,
			pjob->ji_qs.ji_jobid, log_buffer);
	}
	return;
}

/**
 * @brief
 * 	std_file_name - generate the fully qualified path/name for a
 *	job standard stream
 *
 * @param[in]  pjob - pointer to job structure
 * @param[in]  which - identifies which file: StdOut, StdErr, or Chkpt.
 * @param[out] keeping - set true if file to reside in User's Home or sandbox, false if in spool.
 *
 * @return char * - pointer to path which is in a static array.
 *
 */
char *
std_file_name(job *pjob, enum job_file which, int *keeping)
{
	static char  path[MAXPATHLEN+1];
	char  key;
	int   len;
	char *pd;
	char *suffix;

	if ((pjob->ji_wattr[(int)JOB_ATR_interactive].at_flags&ATR_VFLAG_SET) &&
		(pjob->ji_wattr[(int)JOB_ATR_interactive].at_val.at_long > 0)) {

		/* interactive job, name of pty is in outpath */

		*keeping = 0;
		return (pjob->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str);
	}

	switch (which) {
		case StdOut:
			key    = 'o';
			suffix = JOB_STDOUT_SUFFIX;
			break;

		case StdErr:
			key    = 'e';
			suffix = JOB_STDERR_SUFFIX;
			break;

		case Chkpt:
			key = '\001';	/* should never be found */
			suffix = JOB_CKPT_SUFFIX;
			break;

		default:
			break;
	}

	if (pjob->ji_grpcache == NULL)
		return ("");	/* needs to be non-NULL for figuring out homedir path; */

	/* Is file to be kept?, if so use default name in Home directory */

	if ((pjob->ji_wattr[(int)JOB_ATR_keep].at_flags & ATR_VFLAG_SET) &&
		(strchr(pjob->ji_wattr[(int)JOB_ATR_keep].at_val.at_str, key))) {

		/* yes, it is to be kept */

		/* sandbox=private mode set the path to be the path to the */
		/* staging and execution directory                         */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags & ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
		} else {
			(void)strcpy(path, pjob->ji_grpcache->gc_homedir);
		}

		pd = strrchr(pjob->ji_wattr[(int)JOB_ATR_jobname].
#ifdef WIN32
			at_val.at_str, '\\');
#else
			at_val.at_str, '/');
#endif

		if (pd == (char *)0) {
			pd = pjob->ji_wattr[(int)JOB_ATR_jobname].
				at_val.at_str;
#ifdef WIN32
			(void)strcat(path, "\\");
#else
			(void)strcat(path, "/");
#endif
		}

		(void)strcat(path, pd);		/* start with the job name */
		len = strlen(path);
		*(path + len++) = '.';          /* the dot        */
		*(path + len++) = key;		/* the letter     */
		pd = pjob->ji_qs.ji_jobid;      /* the seq_number */
		while (isdigit((int)*pd))
			*(path + len++) = *pd++;
		*(path + len) = '\0';
		*keeping = 1;
	} else {

		/* put into spool directory unless NO_SPOOL_OUTPUT is defined */

#ifdef NO_SPOOL_OUTPUT
		/* sandbox=PRIVATE mode puts output in job staging and execution directory */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags&ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[(int)JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
		} else {        /* force all output to user's HOME */
			(void)strcpy(path, pjob->ji_grpcache->gc_homedir);
		}

#ifdef WIN32
		(void)strcat(path, "\\");
#else
		(void)strcat(path, "/");
#endif

		*keeping = 1;
#else	/* NO_SPOOL_OUTPUT */
		/* sandbox=PRIVATE mode puts output in job staging and execution directory */
		if ((pjob->ji_wattr[(int)JOB_ATR_sandbox].at_flags&ATR_VFLAG_SET) &&
			(strcasecmp(pjob->ji_wattr[(int)JOB_ATR_sandbox].at_val.at_str, "PRIVATE") == 0)) {
			strcpy(path, jobdirname(pjob->ji_qs.ji_jobid, pjob->ji_grpcache->gc_homedir));
#ifdef WIN32
			strcat(path, "\\");
#else
			strcat(path, "/");
#endif
		} else {
			strcpy(path, path_spool);
		}
		*keeping = 0;
#endif	/* NO_SPOOL_OUTPUT */
		if (*pjob->ji_qs.ji_fileprefix != '\0')
			(void)strcat(path, pjob->ji_qs.ji_fileprefix);
		else
			(void)strcat(path, pjob->ji_qs.ji_jobid);
		(void)strcat(path, suffix);
	}
	return (path);
}

/**
 * @brief
 *      Expects the current process will invoke some external program,
 *      and this sets the process to have the special credential
 *      stored in the job, along with 'shell', arguments array (argarray),
 *      and global 'vtable' values.
 *
 * @param[in] pjob - job in question
 * @param[out] shell - if not NULL, filled in with shell to use for future
 *                              external program invocations.
 * @param[out] argarray - if not NULL, filled in with argument array to be
 *                              used for future external program invocations.
 *
 *      Do the right thing for the type of credential the job has.
 *      We are in a child process which will become a task.
 *
 * @return      int
 * @retval      -1      error
 * @retval      0       Success
 *
 */
int
set_credential(job *pjob, char **shell, char ***argarray)
{
	char	**argv;
	char	name_buf[MAXPATHLEN+1];
	static	char	buf[MAXPATHLEN+1];
	int	ret = 0;
	char	*prog;		/* possible new shell */
	char	*name;
	int	i = 0;
	int	j;
	int	usek5dce = 0;
	int	num = 0;
	int	fd, fds[2];

	if (*argarray != NULL) {
		while ((*argarray)[num] != NULL)
			num++;
	}
	cred_buf = NULL;

	switch (pjob->ji_extended.ji_ext.ji_credtype) {

		case PBS_CREDTYPE_GRIDPROXY:
			(void)strcpy(name_buf, path_jobs);
			if (*pjob->ji_qs.ji_fileprefix != '\0')
				(void)strcat(name_buf, pjob->ji_qs.ji_fileprefix);
			else
				(void)strcat(name_buf, pjob->ji_qs.ji_jobid);
			(void)strcat(name_buf, JOB_CRED_SUFFIX);

#ifdef WIN32
			bld_wenv_variables("X509_USER_PROXY", name_buf);
#else
			chown(name_buf, pjob->ji_qs.ji_un.ji_momt.ji_exuid,
				pjob->ji_qs.ji_un.ji_momt.ji_exgid);
			bld_env_variables(&vtable, "X509_USER_PROXY", name_buf);
#endif
			/* fall through */

		case PBS_CREDTYPE_NONE:
			argv = (char **)calloc(2+num, sizeof(char *));
			assert(argv != NULL);

			/* construct argv array */
			if (shell != NULL) {
				prog = *shell;
				name = lastname(*shell);
				argv[i] = malloc(strlen(name) + 2);
				if (argv[i] == NULL) {
					return -1;
				}
				strcpy(argv[i], "-");
				strcat(argv[i++], name);
			}
			ret = becomeuser(pjob);
			break;

		case PBS_CREDTYPE_AES:
			argv = (char **)calloc(2+num, sizeof(char *));
			assert(argv != NULL);

			if (read_cred(pjob, &cred_buf, &cred_len) != 0)
				break;

			ret = becomeuser(pjob);
			if (pipe(fds) == -1) {
				log_err(errno, __func__, "pipe");
				break;
			}

			name = NULL;
			if (pbs_decrypt_pwd(cred_buf, PBS_CREDTYPE_AES, cred_len, &name) != 0) {
				log_err(-1, __func__, "decrypt_pwd");
				close(fds[0]);
			}
			else if (write(fds[1], name, cred_len) != cred_len) {
				log_err(errno, __func__, "pipe write");
				close(fds[0]);
			}
			else {
				sprintf(buf, "%d", fds[0]);
#ifdef WIN32
				bld_wenv_variables("PBS_PWPIPE", buf);
#else
				bld_env_variables(&vtable, "PBS_PWPIPE", buf);
#endif
			}
			if (name != NULL) {
				memset(name, 0, cred_len);
				free(name);
			}
			close(fds[1]);

			/* construct argv array */
			sprintf(buf, "%s/sbin/pbs_dcelogin", pbs_conf.pbs_exec_path);
			prog = buf;
			name = (shell == NULL) ? prog : lastname(prog);
			argv[i++] = name;
			argv[i++] = pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str;

			break;

		case PBS_CREDTYPE_DCE_KRB5:
			argv = (char **)calloc(6+num, sizeof(char *));
			assert(argv != NULL);

			/* create a new cache file */
			if (read_cred(pjob, &cred_buf, &cred_len) != 0)
				break;
			sprintf(name_buf, "%s/krb5cc_pbs%d", TMP_DIR, getpid());
			if ((fd = creat(name_buf, 0600)) == -1) {
				log_err(errno, __func__, name_buf);
				break;
			}
			if (write(fd, cred_buf, cred_len) != cred_len) {
				log_err(errno, __func__, "cred write");
				close(fd);
				break;
			}
#ifndef WIN32
			fchown(fd, pjob->ji_qs.ji_un.ji_momt.ji_exuid,
				pjob->ji_qs.ji_un.ji_momt.ji_exgid);
#endif
			close(fd);

			sprintf(buf, "FILE:%s", name_buf);
#ifdef WIN32
			bld_wenv_variables("KRB5CCNAME", buf);
#else
			bld_env_variables(&vtable, "KRB5CCNAME", buf);
#endif

			sprintf(buf, "%s/sbin/pbs_renew", pbs_conf.pbs_exec_path);
#ifdef	K5DCELOGIN
			/* Doug's program becomes the user based on the DCE cred */
			prog = K5DCELOGIN;
			usek5dce = 1;
#endif	/* K5DCELOGIN */

			if (pbs_conf.k5dcelogin_path != NULL) {
				prog = pbs_conf.k5dcelogin_path;
				usek5dce = 1;
			}
			if (!usek5dce) {	/* not using K5DCELOGIN */
				log_err(errno, __func__, "k5dcelogin unavailable");
				break;
				/*
				 This is for krb5 alone
				 ret = becomeuser(pjob);
				 prog = buf;
				 */
			}

			/* construct argv array */
			name = (shell == NULL) ? prog : lastname(prog);
			argv[i++] = name;
			if (usek5dce) {
				argv[i++] = pjob->ji_wattr[(int)JOB_ATR_euser].
					at_val.at_str;
				argv[i++] = buf;	/* pbs_renew */
			}
			break;

		default:
			log_err(errno, __func__, "unknown credential type");
			return ret;
	}

	if (shell == NULL ||		/* only args OR */
		prog != *shell) {	/* we added a program */
		/* copy remaining command line args */
		if (*argarray != NULL) {
			argv[i++] = (shell == NULL) ?(*argarray)[0] : *shell;
			for (j=1; (*argarray)[j]; j++)
				argv[i++] = (*argarray)[j];
		}
		else
			argv[i++] = (shell == NULL) ? NULL : *shell;
		if (shell != NULL)
			*shell = prog;
	}
	argv[i++] = (char *)0;
	*argarray = argv;

	if (cred_buf) {
		free(cred_buf);
		cred_buf = NULL;
	}
	return ret;
}


