/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/*
 * @file	svr_preemptjob.c
 *
 * Functions relating to the Hold and Release Job Batch Requests.
 *
 * Included funtions are:
 *	req_holdjob()
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "server.h"
#include "batch_request.h"
#include "net_connect.h"
#include "job.h"
#include "pbs_error.h"
#include "log.h"
#include "acct.h"
#include "pbs_nodes.h"
#include "svrfunc.h"

extern void post_signal_req(struct work_task *);
int shutdown_preempt_chkpt(job *pjob, struct batch_request *nest);
struct preempt_ordering *svr_get_preempt_order(job *pjob, pbs_sched *psched);

/* Global Data Items: */

extern struct server server;

extern time_t time_now;

/**
 * @brief
 * req_preemptjobs- service the Preempt Jobs Request
 *
 * This request tries to preempt multiple jobs.
 * The state of the job may change as a result.
 *
 * @param[in,out]	preq	- The Request
 */

void
req_preemptjobs(struct batch_request *preq)
{
	int			i = 0;
	int			j = 0;
	int			count = 0;
	job			*pjob = NULL;
	preempt_job_info	*ppj = NULL;
	pbs_sched		*psched;

	preq->rq_reply.brp_code = 0;
	count = preq->rq_ind.rq_preempt.count;
	psched = find_sched_from_sock(preq->rq_conn);

	for (i = 0; i < count; i++) {
		ppj = &(preq->rq_ind.rq_preempt.ppj_list[i]);
		pjob = find_job(ppj->job_id);

		pjob->preempt_order = svr_get_preempt_order(pjob, psched);
		pjob->preempt_order_index = 0;
		switch((int)pjob->preempt_order[0].order[j]) {
			case PREEMPT_METHOD_SUSPEND:
				issue_signal(pjob, SIG_SUSPEND, post_signal_req, pjob, preq);
				break;
			case PREEMPT_METHOD_CHECKPOINT:
				shutdown_preempt_chkpt(pjob, preq);
				break;
			case PREEMPT_METHOD_REQUEUE:
				issue_signal(pjob, SIG_RERUN, post_rerun, pjob, preq);
				break;
		}
	}
}

/**
 * @brief
 * reply_preempt_jobs_request- synthesize and reply to Preempt Jobs Request
 *
 * If an attempt to preempt the job fails, we use the next method to preempt
 * that job as per the preemption order,
 *
 * If the job gets preempted successfully, job-id is added to the reply.
 *
 * @param[in] code - determines if the job was preempted or not.
 * @param[in] aux  - determines the method by which job was preempted.
 * @param[in] local_preq - contains the job information and the scheuler
 *                         request to which reply is to be sent.
 */

void
reply_preempt_jobs_request(int code, int aux, struct batch_request *local_preq)
{
	job *pjob;
	int newsub;
	int newstate;
	attribute temphold;
	struct batch_request *preq = local_preq->rq_nest;
	struct batch_reply *preply = &(preq->rq_reply);

	static int count = 0;
	static int index = 0;
	static preempt_job_info	*preempt_jobs_list = NULL;

	count = preq->rq_ind.rq_preempt.count;
	pjob = local_preq->rq_extra;

	if (preempt_jobs_list == NULL) {
		if ((preempt_jobs_list = calloc(sizeof(preempt_job_info), count)) == NULL) {
			log_err(errno, __func__, "Unable to allocate memory");
			return;
		}
	}

	preply->brp_choice = BATCH_REPLY_CHOICE_PreemptJobs;
	preply->brp_un.brp_preempt_jobs.count = preq->rq_ind.rq_preempt.count;

	if (code != PBSE_NONE) {
		switch ((int)pjob->preempt_order[0].order[pjob->preempt_order_index+1]) {
			case PREEMPT_METHOD_SUSPEND:
				issue_signal(pjob, SIG_SUSPEND, post_signal_req, pjob, preq);
				break;
			case PREEMPT_METHOD_CHECKPOINT:
				shutdown_preempt_chkpt(pjob, preq);
				break;
			case PREEMPT_METHOD_REQUEUE:
				issue_signal(pjob, SIG_RERUN, post_rerun, pjob, preq);
				break;
			default:
				/* preemption failed */
				preply->brp_code = 1;
				strcpy(preempt_jobs_list[index].order, "000");
				break;
		}
		pjob->preempt_order_index++;
	} else {
		/* successful preemption */
		long old_hold;
		pjob->ji_wattr[(int)JOB_ATR_sched_preempted].at_val.at_long = time(0);
		switch (aux) {
			case 1:
				strcpy(preempt_jobs_list[index].order, "S");
				break;
			case 2:
				strcpy(preempt_jobs_list[index].order, "C");

				clear_attr(&temphold, &job_attr_def[(int)JOB_ATR_hold]);
				job_attr_def[(int)JOB_ATR_hold].at_decode(
					&temphold,
					NULL,
					NULL,
					"s");

				old_hold = pjob->ji_wattr[(int)JOB_ATR_hold].at_val.at_long;
				job_attr_def[(int)JOB_ATR_hold].
					at_set(&pjob->ji_wattr[(int)JOB_ATR_hold],
					&temphold, DECR);
				log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);


				if (old_hold != pjob->ji_wattr[(int)JOB_ATR_hold].at_val.at_long) {
					pjob->ji_modified = 1;	/* indicates attributes changed    */
					log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);

					svr_evaljobstate(pjob, &newstate, &newsub, 0);
					(void)svr_setjobstate(pjob, newstate, newsub); /* saves job */

					log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);
				}
				if (pjob->ji_wattr[(int)JOB_ATR_hold].at_val.at_long == 0)
					job_attr_def[(int)JOB_ATR_Comment].at_free(&pjob->ji_wattr[(int)JOB_ATR_Comment]);
				break;
			case 3:
				strcpy(preempt_jobs_list[index].order, "Q");
				break;
		}
		sprintf(preempt_jobs_list[index].job_id, "%s", pjob->ji_qs.ji_jobid);
		index++;
	}

	if (index == count) {
		/* Send reply */
		preply->brp_un.brp_preempt_jobs.ppj_list = preempt_jobs_list;
		reply_send(preq);
		free(preempt_jobs_list);
		index = 0;
		count = 0;
		preempt_jobs_list = NULL;
	}
}

/**
 * @brief
 *  get_job_req_used_time - get a running job's req and used time for preemption
 *
 * @param[in]	pjob - the job in question
 * @param[out]	rtime - return pointer to the requested time
 * @param[out]	utime - return pointer to the used time
 *
 * @return	int
 * @retval	0 for success
 * @retval	1 for error
 */
static int
get_job_req_used_time(job *pjob, double *rtime, double *utime)
{
	double req = 0;
	double used = 0;

	if (pjob == NULL || rtime == NULL || utime == NULL)
		return 1;

	req = get_softwall(pjob);
	if (req == -1)
		req = get_wall(pjob);

	if (req == -1) {
		req = get_cput(pjob);
		used = get_used_cput(pjob);
	} else
		used = get_used_wall(pjob);

	*rtime = req;
	*utime = used;

	return 0;
}

/**
 * @brief
 *  	svr_get_preempt_order - deduce the preemption ordering to be used for a job
 *
 * @param[in]	pjob	-	the job to preempt
 * @param[in]	psched	-	Pointer to the sched object.
 *
 * @return	: struct preempt_ordering.  array containing preemption order
 *
 */
struct preempt_ordering *svr_get_preempt_order(job *pjob, pbs_sched *psched)
{
	struct preempt_ordering *po = NULL;
	double req = -1;
	double used = -1;

	if (get_job_req_used_time(pjob, &req, &used) != 0)
		return NULL;

	if (used == -1 || req == -1) {
		snprintf(log_buffer, sizeof(log_buffer),
				"No walltime/cput to determine percent of time left - will use first preempt_order");
		log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);
	}

	po = get_preemption_order(psched->preempt_order, req, used);

	return po;
}
