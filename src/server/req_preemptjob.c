/*
 * Copyright (C) 1994-2018 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */
/*
 * @file	svr_preemptjob.c
 *
 * Functions relating to the Hold and Release Job Batch Requests.
 *
 * Included funtions are:
 *	req_holdjob()
 *
 */
#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <time.h>
#include <sys/types.h>
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "server.h"
#include "batch_request.h"
#include "net_connect.h"
#include "job.h"
#include "pbs_error.h"
#include "log.h"
#include "acct.h"
#include "pbs_nodes.h"
#include "svrfunc.h"

extern void post_signal_req(struct work_task *);
int shutdown_preempt_chkpt(job *pjob, struct batch_request *nest);
struct preempt_ordering *get_preemption_order(job *pjob, pbs_sched *psched);

/* Private Functions Local to this file */

/* Global Data Items: */

extern struct server server;

extern time_t	 time_now;

/* Private Data */


/**
 * @brief
 * 		req_preemptjobs- service the Preempt Jobs Request
 *
 *		This request tries to preempt multiple jobs.
 *		The state of the job may change as a result.
 *
 * @param[in,out]	preq	- The Request
 */

void
req_preemptjobs(struct batch_request *preq)
{
	int			i = 0;
	int			j = 0;
	int			count = 0;
	job			*pjob = NULL;
	preempt_job_info	*ppj = NULL;
	pbs_sched		*psched;

	preq->rq_reply.brp_code = 0;
	count = preq->rq_ind.rq_preempt.count;
	psched = find_sched_from_sock(preq->rq_conn);

	for (i = 0; i < count; i++) {
		ppj = &(preq->rq_ind.rq_preempt.ppj_list[i]);
		pjob = find_job(ppj->job_id);

		pjob->preempt_order = get_preemption_order(pjob, psched);
		pjob->preempt_order_index = 0;
		switch((int)pjob->preempt_order[0].order[j]) {
			case PREEMPT_METHOD_SUSPEND:
				issue_signal(pjob, SIG_SUSPEND, post_signal_req, pjob, preq);
				break;
			case PREEMPT_METHOD_CHECKPOINT:
				shutdown_preempt_chkpt(pjob, preq);
				break;
			case PREEMPT_METHOD_REQUEUE:
				issue_signal(pjob, SIG_RERUN, post_signal_req, pjob, preq);
				break;
		}
	}
}

void
reply_preempt_jobs_request(int code, int aux, struct batch_request *local_preq)
{
	struct batch_request	*preq = local_preq->rq_nest;
	struct batch_reply	*preply = &(preq->rq_reply);
	char			*job_id;
	job			*pjob;

	static int		count = 0;
	static int		index = 0;
	static preempt_job_info	*preempt_jobs_list = NULL;

	count = preq->rq_ind.rq_preempt.count;
	pjob = local_preq->rq_extra;

	if (preempt_jobs_list == NULL) {
		if ((preempt_jobs_list = calloc(sizeof(preempt_job_info), count)) == NULL) {
			log_err(errno, __func__, "Unable to allocate memory");
			return;
		}
	}

	preply->brp_choice = BATCH_REPLY_CHOICE_PreemptJobs;
	preply->brp_un.brp_preempt_jobs.count = preq->rq_ind.rq_preempt.count;

	job_id = pjob->ji_qs.ji_jobid;
	sprintf(preempt_jobs_list[index].job_id, "%s", job_id);

	if (code != PBSE_NONE) {
		switch ((int)pjob->preempt_order[0].order[pjob->preempt_order_index+1]) {
			case PREEMPT_METHOD_SUSPEND:
				issue_signal(pjob, SIG_SUSPEND, post_signal_req, pjob, preq);
				break;
			case PREEMPT_METHOD_CHECKPOINT:
				shutdown_preempt_chkpt(pjob, preq);
				break;
			case PREEMPT_METHOD_REQUEUE:
				issue_signal(pjob, SIG_RERUN, post_signal_req, pjob, preq);
				break;
			default:
				/* preemption failed */
				preply->brp_code = 1;
				strcpy(preempt_jobs_list[index].order, "000");
				break;
		}
		pjob->preempt_order_index++;
	} else {
		/* successful preemption */
		switch (aux) {
			case 1:
				strcpy(preempt_jobs_list[index].order, "S");
				break;
			case 2:
				strcpy(preempt_jobs_list[index].order, "C");
				break;
			case 3:
				strcpy(preempt_jobs_list[index].order, "Q");
				break;
		}
	}

	preply->brp_un.brp_preempt_jobs.ppj_list = preempt_jobs_list;
	index++;

	if (index == count) {
		/* Send reply */
		reply_send(preq);
		free(preempt_jobs_list);
		index = 0;
		preempt_jobs_list = NULL;
	} else
		return;

}

/**
 * @brief
 *  	get_preemption_order - deduce the preemption ordering to be used for a job
 *
 * @param[in]	pjob	-	the job to preempt
 * @param[in]	sinfo	-	Pointer to server info structure.
 *
 * @return	: struct preempt_ordering.  array containing preemption order
 *
 */
struct preempt_ordering *get_preemption_order(job *pjob,
	pbs_sched *psched)
{
	int i;
	double req = 0;
	double used = 0;
	double percent_left = 0;
	/* the order to preempt jobs in */
	struct preempt_ordering *po = &psched->preempt_order[0];

	if (pjob == NULL)
		return 0;

	/* check if we have more then one range... no need to choose if not */
	if (psched->preempt_order[1].high_range != 0) {
		req = get_softwall(pjob);
		if (req == -1)
			req = get_wall(pjob);

		if (req == -1) {
			req = get_cput(pjob);
			used = get_used_cput(pjob);
		} else
			used = get_used_wall(pjob);

		if (used == -1 || req == -1) {
			snprintf(log_buffer, sizeof(log_buffer), "No walltime/cput to determine percent of time left - will use first preempt_order");
			log_event(PBSEVENT_JOB, PBS_EVENTCLASS_JOB, LOG_INFO, pjob->ji_qs.ji_jobid, log_buffer);
		} else {

			percent_left = (int)(100 - (used / req) * 100);

			if (percent_left < 0)
				percent_left = 1;

			for (i = 0; i < PREEMPT_ORDER_MAX; i++) {
				if (percent_left <= psched->preempt_order[i].high_range &&
					percent_left >= psched->preempt_order[i].low_range) {
					po = &psched->preempt_order[i];
					break;
				}
			}
		}
	}
	return po;
}
