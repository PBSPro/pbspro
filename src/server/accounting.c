/*
 * Copyright (C) 1994-2019 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * PBS Pro is free software. You can redistribute it and/or modify it under the
 * terms of the GNU Affero General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * PBS Pro is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * For a copy of the commercial license terms and conditions,
 * go to: (http://www.pbspro.com/UserArea/agreement.html)
 * or contact the Altair Legal Department.
 *
 * Altair’s dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of PBS Pro and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair’s trademarks, including but not limited to "PBS™",
 * "PBS Professional®", and "PBS Pro™" and Altair’s logos is subject to Altair's
 * trademark licensing policies.
 *
 */

/**
 * @file    accounting.c
 *
 * @brief
 * accounting.c - contains functions to record accounting information
 *
 * Functions included are:
 *	acct_open()
 *	acct_record()
 *	acct_close()
 */



#include <pbs_config.h>   /* the master config generated by configure */
#include "portability.h"
#ifndef  WIN32
#include <sys/param.h>
#endif
#include <ctype.h>
#include <sys/types.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server_limits.h"
#include "job.h"
#include "reservation.h"
#include "queue.h"
#include "pbs_nodes.h"
#include "log.h"
#include "acct.h"
#include "pbs_license.h"
#include "server.h"
#include "svrfunc.h"
#include "libutil.h"

/* Local Data */

static FILE	    *acctfile;		/* open stream for log file */
static volatile int  acct_opened = 0;
static int	     acct_opened_day;
static int	     acct_auto_switch = 0;
static char	    *acct_buf = 0;
static int	     acct_bufsize = PBS_ACCT_MAX_RCD;

/* Global Data */

extern char	    *acctlog_spacechar;
extern attribute_def job_attr_def[];
extern char	    *path_acct;
extern int	     resc_access_perm;
extern time_t	     time_now;
extern struct resc_sum *svr_resc_sum;
extern struct server server;
extern char *msg_job_end_stat;

/**
 * @brief
 * sum_resc_alloc() - sums up the consumable resources listed in
 *	the exec_vnode for accounting.  The caller is responsible
 *	for taking the sums in svr_resc_sum[] and formating the
 *	data into a buffer for logging.
 *
 * @param[in]	pjob - pointer to job
 * @param[in]	list - pbs list head
 *
 * @return      Error code
 * @retval	0			- if ok and data in svr_resc_sum[]
 * @retval  non zero	- on error and data is not valid
 *
 * @par MT-safe: No
 */

static void
sum_resc_alloc(job *pjob, pbs_list_head *list)
{
	char	  *chunk;
	char	  *exechost;
	int        i;
	int        j;
	int        nelem;
	char	  *noden;
	struct key_value_pair *pkvp;
	resource          *presc;
	struct pbsnode    *pnode;
	int	           rc;

	static attribute   tmpatr;


	if ((pjob == NULL) ||
		!(pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_flags & ATR_VFLAG_SET))
		return;

	/* if a vnode was allocated "excl",  we need to charge all of its   */
	/* resources, but only once.   So we need to mark the vnode as seen */
	/* To do that, we first need to unmark them...			    */

	for (i=0; i<svr_totnodes; i++)
		pbsndlist[i]->nd_accted = 0;

	exechost = pjob->ji_wattr[(int)JOB_ATR_exec_vnode].at_val.at_str;

	/* clear the summation table used later */

	for (i=0; svr_resc_sum[i].rs_def; ++i) {
		(void)memset((char *)&svr_resc_sum[i].rs_attr, 0, sizeof(struct attribute));

		svr_resc_sum[i].rs_set = 0;
		svr_resc_sum[i].rs_prs = NULL;
	}

	/* now, go through the exec_vnode specified for the job, for any       */
	/* resource that matches an entry in the table, set the pointer and set flag */

	chunk = parse_plus_spec(exechost, &rc);
	if (rc != 0)
		return;
	while (chunk) {
		if (parse_node_resc(chunk, &noden, &nelem, &pkvp) == 0) {

			/* find if node is shared or excl */

			pnode = find_nodebyname(noden);
			if (pnode) {
				if ((pnode->nd_state & INUSE_JOBEXCL) == 0) {

					/* shared, record only what was requested from the vnode */

					for (j=0; j<nelem; ++j) {
						for (i=0; svr_resc_sum[i].rs_def; ++i) {
							if (strcmp(svr_resc_sum[i].rs_def->rs_name, pkvp[j].kv_keyw) == 0) {
								/* incr sum by amount requested by user */
								rc = svr_resc_sum[i].rs_def->rs_decode(&tmpatr,
									0, 0, pkvp[j].kv_val);
								if (rc != 0)
									return;
								(void)svr_resc_sum[i].rs_def->rs_set(&svr_resc_sum[i].rs_attr, &tmpatr, INCR);

								svr_resc_sum[i].rs_set = 1;
							}
						}
					}

				} else if (pnode->nd_accted == 0) {

					/* vnode used exclusively and not already accounted, */
					/* so incr sum by amount in whole vnode              */

					pnode->nd_accted = 1;  /* mark that it has been recorded */
					for (i=0; svr_resc_sum[i].rs_def; ++i) {
						presc = find_resc_entry(&pnode->nd_attr[(int)ND_ATR_ResourceAvail], svr_resc_sum[i].rs_def);
						if (presc && (presc->rs_value.at_flags & ATR_VFLAG_SET)) {
							(void)svr_resc_sum[i].rs_def->rs_set(&svr_resc_sum[i].rs_attr, &presc->rs_value, INCR);
							svr_resc_sum[i].rs_set = 1;
						}
					}
				}
			}

		} else {
			return;
		}
		chunk = parse_plus_spec(NULL, &rc);
		if (rc != 0)
			return;
	}

	for (i=0; svr_resc_sum[i].rs_def != NULL; ++i) {
		if (svr_resc_sum[i].rs_set) {
			(void)svr_resc_sum[i].rs_def->rs_encode(
				&svr_resc_sum[i].rs_attr,
				list,
				"resource_assigned",
				svr_resc_sum[i].rs_def->rs_name,
				ATR_ENCODE_CLIENT, NULL);
		}
	}

	return;
}

/**
 * @brief
 * cpy_quote_value - append the value to the buffer
 *	If the string is alphanumeric, it is appended as is.
 *	If the string contains alphanumeric characters quote the 
 *	string with " characters and then append it.
 *	If the string contains a " or \, they are escaped with \.
 *
 * @param[in,out]	buf - Source string and stores the result after appending.
 * @param[in,out]	buf_size - allocated length of the source string.
 * @param[in]		value - value which needs to be appended
 * @param[in]		fmt - format string used to append the value
 *
 * @return      int
 * @retval	success - 0
 * @retval	failure - -1
 *
 * @par MT-safe:   No
 */
int 
cpy_quote_value(char **buf, int *buf_size, char *value, char *fmt) 
{
	char		*temp2 = NULL;
	static char	*temp = NULL;
	int		ret = -1;

	if (value && value[0]) {		
		int		need_quotes = 0;
		int		value_index = 0;
		int		dest_index = 1;
		static int      current_temp_len = 0;
		int len = strlen(value);
		/*
		 * upper limit for length of the temp string is to accomodate as many
		 * escapes as the length of the value in addition to the length of the
		 * format string along with two surrounding quotes (2 bytes) and the 
		 * NUL (1 byte) at the end.
		 */
		int required_length_estimate = len * 2 + strlen(fmt) + 3;
		if (!temp || (current_temp_len < required_length_estimate)) {
			temp2 = realloc(temp, required_length_estimate);
			if (!temp2) {
				log_err(errno, __func__, "Unable to allocate memory.");
				return ret;
			}
			temp = temp2;
			temp[0] = '\0';
			current_temp_len = required_length_estimate;
		}
		for (; value_index < len; value_index++) {
			if (!isalnum(value[value_index]) && value[value_index] != '_') {
				if (value[value_index] == '\\' || value[value_index] == '\"')
					temp[dest_index++] = '\\';

				temp[dest_index++] = value[value_index];
				need_quotes = 1;
			} else
				temp[dest_index++] = value[value_index];
		}
		if (need_quotes) {
			if ((value[0] != '\"' && value[len-1] != '\"') ||
			    ((value[0] == '\"' && value[len-1] != '\"') ||
			    (value[0] != '\"' && value[len-1] == '\"'))) {
				temp[0] = '\"';
				temp[dest_index++] = '\"';
				temp[dest_index] = '\0';
				if (!pbs_strcat(buf, buf_size, fmt)) {
					log_err(errno, __func__, "Failed to allocate memory."); 
					return ret;
				}
				if (!pbs_strcat(buf, buf_size, temp)) {
					log_err(errno, __func__, "Failed to allocate memory.");
					return ret;
				}
			} else {
				temp[dest_index] = '\0';
				if (!pbs_strcat(buf, buf_size, fmt)) {
					log_err(errno, __func__, "Failed to allocate memory.");
					return ret;
				}
				if (!pbs_strcat(buf, buf_size, &temp[1])) {
					log_err(errno, __func__, "Failed to allocate memory.");
					return ret;
				}
			}
		} else {
			temp[dest_index] = '\0';
			if (!pbs_strcat(buf, buf_size, fmt)) {
				log_err(errno, __func__, "Failed to allocate memory.");
				return ret;
			}
			if (!pbs_strcat(buf, buf_size, &temp[1])) {
				log_err(errno, __func__, "Failed to allocate memory.");
				return ret;
			}
		}
		ret = 0;
	}
	return ret;
}

/* These are various printing formats used in acct_job() and acct_resv() */
#define	GRIDNAME_FMT		"gridname="
#define	USER_FMT		"user="
#define	GROUP_FMT		" group="
#define	ACCOUNT_FMT		" account="
#define	PROJECT_FMT		" project="
#define	ACCOUNTING_ID_FMT	" accounting_id="
#define	JOBNAME_FMT		" jobname="
#define	QUEUE_FMT		" queue="
#define	RESVNAME_FMT		" resvname="
#define	RESVID_FMT		" resvID="
#define	RESVJOBID_FMT		" resvjobID="
#define	ARRAY_INDICES_FMT	" array_indices="
#define	EXEC_HOST_FMT		" exec_host="
#define	EXEC_VNODE_FMT		" exec_vnode="
#define	RESV_OWNER_FMT		" owner="
#define	RESV_NAME_FMT		" name="
#define	RESV_NODES_FMT		" nodes="
#define	JOB_ALTID_FMT		" alt_id="
#define	PROV_NODE_FMT		" provision_vnode="
#define	RUNCOUNT_FMT		" run_count="

/* Amount of space needed in account log buffer for the ctime, qtime, etime, */
/* start attributes */
#define ACCTBUF_TIMES_NEED	90

/**
 * @brief
 *	Get the value of "walltime" resource for the job's given
 *	resource index 'res'.
 *
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	res	- resource entity index (e.g. JOB_ATR_resource)
 *
 * @return	long
 * @retval	<n>	walltime value
 * @retval	-1	if error encountered.
 *
 */
long
get_walltime(job *jp, int res)
{
	resource_def	*rscdef;
	resource	*pres;

	rscdef = find_resc_def(svr_resc_def, "walltime", svr_resc_size);
	if (rscdef == NULL)
		return (-1);
	pres = find_resc_entry(&jp->ji_wattr[res], rscdef);
	if (pres == NULL)
		return (-1);
	else if ((pres->rs_value.at_flags & ATR_VFLAG_SET) == 0)
		return (-1);
	else
		return pres->rs_value.at_val.at_long;   /*wall time value*/
}

/**
 * @brief
 *	Form and write a job termination/rerun record with resource usage.
 * 	Build common data for start/end job accounting record
 *
 * @par	Functionality:
 *	Used by account_jobstr() and account_jobend()
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	buf	- buffer holding the data that will be stored in
 *			  accounting logs.
 * @param[in]	len	- pointer to the size of 'buf'.
 * @return	void
 *
 */
static void
acct_job(job *pjob, int type, char **buf, int *len)
{
	pbs_list_head 	attrlist;
	svrattrl 	*pal = NULL;
#ifdef WIN32
	char		*win_str = NULL;
#endif
	char 		timestr[ACCTBUF_TIMES_NEED] = {0};
	char            save_char = 0;
	int		att_index;
	int		k = 0;
	int		old_perm;
	int		len_orig;

	CLEAR_HEAD(attrlist);

	/* gridname */
	if (pjob->ji_wattr[(int)JOB_ATR_gridname].at_flags & ATR_VFLAG_SET) {
		if (!pbs_strcat(buf, len, GRIDNAME_FMT)) 
			return;
		if (!pbs_strcat(buf, len, pjob->ji_wattr[(int)JOB_ATR_gridname].at_val.at_str))
			return;
		if (!pbs_strcat(buf, len, " "))
			return;
	}

	/* user */
	if (!pbs_strcat(buf, len, USER_FMT)) 
		return;
#ifdef WIN32
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, acctlog_spacechar);
	if (!pbs_strcat(buf, len, win_str))
		return;
#else
	if (!pbs_strcat(buf, len, pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str))
		return;
#endif

	/* group */
	if (!pbs_strcat(buf, len, GROUP_FMT)) 
		return;
#ifdef WIN32
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str, acctlog_spacechar);
	if (!pbs_strcat(buf, len, win_str))
		return;
#else
	if (!pbs_strcat(buf, len, pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str))
		return;
#endif

	/* account */
	if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET) {
#ifdef WIN32
		win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str, acctlog_spacechar);
		if (cpy_quote_value(buf, len, win_str, ACCOUNT_FMT) == -1)
			return;
#else
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str, ACCOUNT_FMT) == -1)
			return;
#endif
	}

	/* project */
	if (pjob->ji_wattr[(int)JOB_ATR_project].at_flags & ATR_VFLAG_SET) {
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_project].at_val.at_str, PROJECT_FMT) == -1)
			return;
	}

	/* accounting_id */
	if (pjob->ji_wattr[(int)JOB_ATR_acct_id].at_flags & ATR_VFLAG_SET) {
		if (!pbs_strcat(buf, len, ACCOUNTING_ID_FMT)) 
			return;
		if (!pbs_strcat(buf, len, pjob->ji_wattr[(int)JOB_ATR_acct_id].at_val.at_str))
			return;
	}

	/* job name */
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str, JOBNAME_FMT) == -1)
		return;

	/* queue name */
	if (!pbs_strcat(buf, len, QUEUE_FMT)) 
		return;
	if (!pbs_strcat(buf, len, pjob->ji_qhdr->qu_qs.qu_name))
		return;

	if (pjob->ji_myResv) {
		/* reservation name */
		if (pjob->ji_myResv->ri_wattr[(int)RESV_ATR_resv_name].at_flags & ATR_VFLAG_SET) {
			if (cpy_quote_value(buf, len, pjob->ji_myResv->ri_wattr[(int)RESV_ATR_resv_name].at_val.at_str, RESVNAME_FMT) == -1)
				return;
		}
		/* reservation ID */
		if (!pbs_strcat(buf, len, RESVID_FMT)) 
			return;
		if (!pbs_strcat(buf, len, pjob->ji_myResv->ri_qs.ri_resvID))
			return;
	}

	if (pjob->ji_resvp) {
		/* resvjob ID */
		if (!pbs_strcat(buf, len, RESVJOBID_FMT)) 
			return;
		if (!pbs_strcat(buf, len, pjob->ji_resvp->ri_qs.ri_resvID))
			return;
	}

	/* create time, queued time, eligible time, how long ready to run, and execution start time */
	snprintf(timestr, ACCTBUF_TIMES_NEED,
		 " ctime=%ld qtime=%ld etime=%ld start=%ld",
		 pjob->ji_wattr[(int)JOB_ATR_ctime].at_val.at_long,
		 pjob->ji_wattr[(int)JOB_ATR_qtime].at_val.at_long,
		 pjob->ji_wattr[(int)JOB_ATR_etime].at_val.at_long,
		 (long)pjob->ji_qs.ji_stime);
	if (!pbs_strcat(buf, len, timestr))
		return;

	if (pjob->ji_wattr[(int)JOB_ATR_array_indices_submitted].at_flags & ATR_VFLAG_SET && (pjob->ji_qs.ji_state == JOB_STATE_BEGUN)) {
		/* for an Array Job in Begun state,  record index range */
		if (!pbs_strcat(buf, len, ARRAY_INDICES_FMT)) 
			return;
		if (!pbs_strcat(buf, len, pjob->ji_wattr[(int)JOB_ATR_array_indices_submitted].at_val.at_str))
			return;
	} else {
		/* regular job */
		if ((type == PBS_ACCT_END) &&
		    (pjob->ji_wattr[(int)JOB_ATR_exec_host_orig].at_flags & ATR_VFLAG_SET))
			att_index = JOB_ATR_exec_host_orig;
		else
			att_index = JOB_ATR_exec_host;

		if (pjob->ji_wattr[att_index].at_flags & ATR_VFLAG_SET) {
			/* execution host list, may be loooong */
			if (!pbs_strcat(buf, len, EXEC_HOST_FMT)) 
				return;
			if (!pbs_strcat(buf, len, pjob->ji_wattr[att_index].at_val.at_str))
				return;
		}

		if ((type == PBS_ACCT_END) &&
		    (pjob->ji_wattr[(int)JOB_ATR_exec_vnode_orig].at_flags & ATR_VFLAG_SET))
			att_index = JOB_ATR_exec_vnode_orig;
		else
			att_index = JOB_ATR_exec_vnode;

		if (pjob->ji_wattr[att_index].at_flags & ATR_VFLAG_SET) {
			/* execution vnode list, will be even longer */
			if (!pbs_strcat(buf, len, EXEC_VNODE_FMT)) 
				return;
			if (!pbs_strcat(buf, len, pjob->ji_wattr[att_index].at_val.at_str))
				return;
		}
	}


	/* now encode the job's resource_list attribute */
	/* of the just concluded phase */
	old_perm = resc_access_perm;
	resc_access_perm = READ_ONLY;
	if ((type == PBS_ACCT_END) &&
            (pjob->ji_wattr[(int)JOB_ATR_resource_orig].at_flags & ATR_VFLAG_SET)) {
                att_index = JOB_ATR_resource_orig;
                len_orig = 5; /* length of "_orig" */
        } else {
                att_index = JOB_ATR_resource;
                len_orig = 0;
        }	
	(void)job_attr_def[att_index].at_encode(
		&pjob->ji_wattr[att_index],
		&attrlist,
		job_attr_def[att_index].at_name,
		NULL,
		ATR_ENCODE_CLIENT, NULL);
	resc_access_perm = old_perm;

	while((pal = GET_NEXT(attrlist)) != NULL) {
		/* strip off the '_orig' suffix */
		if (len_orig > 0) {
			k = strlen(pal->al_name);
                        if (k  > len_orig) {
                                save_char = pal->al_name[k-len_orig];
                                pal->al_name[k-len_orig] = '\0';
                        }
                }
		if (strlen(pal->al_value) > 0)
			if (concat_rescused_to_buffer(buf, len, pal, " ", pjob, 1) != 0)
				return; 
		if (len_orig > 0) {
                        if (k  > len_orig) {
                                pal->al_name[k-len_orig] = save_char;
                        }
                }
		delete_link(&pal->al_link);
		(void)free(pal);
	}
	return;
}

/**
 * @brief
 * acct_resv - build data for start/end reservation  accounting record
 *
 * @par	Functionality:
 *	Used by account_resvstr() and account_resvend()
 *
 * @param[in]	presv	- pointer to reservation structure
 * @param[in]	buf	- buffer holding the data that will be stored in
 *			  accounting logs.
 * @param[in]	len	- pointer to the number of characters in 'buf'
 * @return	void
 */
static void
acct_resv(resc_resv *presv, char **buf, int *len)
{
	pbs_list_head	attrlist;	/*retrieved resources list put here*/
	svrattrl	*pal = NULL;
	char		timestr[ACCTBUF_TIMES_NEED] = {0};
	int		old_perm;

	CLEAR_HEAD(attrlist);

	/* owner */
	if (cpy_quote_value(buf, len, presv->ri_wattr[(int)RESV_ATR_resv_owner].at_val.at_str, RESV_OWNER_FMT) == -1)
		return;
	/* name */
	if (presv->ri_wattr[(int)RESV_ATR_resv_name].at_flags & ATR_VFLAG_SET)
		if (cpy_quote_value(buf, len, presv->ri_wattr[(int)RESV_ATR_resv_name].at_val.at_str, RESV_NAME_FMT) == -1)
			return;

	/* account */
	if (presv->ri_wattr[(int)RESV_ATR_account].at_flags & ATR_VFLAG_SET)
		if (cpy_quote_value(buf, len, presv->ri_wattr[(int)RESV_ATR_account].at_val.at_str, ACCOUNT_FMT) == -1)
			return;

	/* queue name */
	if ((presv->ri_qs.ri_type == RESC_RESV_OBJECT) && (presv->ri_qp != NULL)) {
		if (cpy_quote_value(buf, len, presv->ri_qp->qu_qs.qu_name, QUEUE_FMT) == -1)
			return;
	} else if (presv->ri_qs.ri_type == RESV_JOB_OBJECT && presv->ri_jbp) {
		if (cpy_quote_value(buf, len, presv->ri_jbp->ji_qhdr->qu_qs.qu_name, QUEUE_FMT) == -1)
			return;
	}

	/* create time, start time, end time, duration */
	snprintf(timestr, ACCTBUF_TIMES_NEED,
		 " ctime=%ld start=%ld end=%ld duration=%ld",
		 presv->ri_wattr[(int)RESV_ATR_ctime].at_val.at_long,
		 (long)presv->ri_qs.ri_stime,
		 (long)presv->ri_qs.ri_etime,
		 (long)presv->ri_qs.ri_duration
		);
	if (!pbs_strcat(buf, len, timestr))
		return;

	/* nodes string may be loooong */
	if (presv->ri_wattr[(int)RESV_ATR_resv_nodes].at_flags & ATR_VFLAG_SET)
		if (cpy_quote_value(buf, len, presv->ri_wattr[(int)RESV_ATR_resv_nodes].at_val.at_str, RESV_NODES_FMT) == -1)
			return;

	/* now encode any user, group or host ACL */

	old_perm = resc_access_perm;
	resc_access_perm = READ_ONLY;
	(void)resv_attr_def[(int)RESV_ATR_auth_u].at_encode(
		&presv->ri_wattr[(int)RESV_ATR_auth_u],
		&attrlist,
		resv_attr_def[(int)RESV_ATR_auth_u].at_name,
		NULL,
		ATR_ENCODE_CLIENT, NULL);

	(void)resv_attr_def[(int)RESV_ATR_auth_g].at_encode(
		&presv->ri_wattr[(int)RESV_ATR_auth_g],
		&attrlist,
		resv_attr_def[(int)RESV_ATR_auth_g].at_name,
		NULL,
		ATR_ENCODE_CLIENT, NULL);

	(void)resv_attr_def[(int)RESV_ATR_auth_h].at_encode(
		&presv->ri_wattr[(int)RESV_ATR_auth_h],
		&attrlist,
		resv_attr_def[(int)RESV_ATR_auth_h].at_name,
		NULL,
		ATR_ENCODE_CLIENT, NULL);


	/* now encode the reservation's resource_list attribute */

	resc_access_perm = READ_ONLY;
	(void)resv_attr_def[(int)RESV_ATR_resource].at_encode(
		&presv->ri_wattr[(int)RESV_ATR_resource],
		&attrlist,
		resv_attr_def[(int)RESV_ATR_resource].at_name,
		NULL,
		ATR_ENCODE_CLIENT, NULL);
	resc_access_perm = old_perm;

	while((pal = GET_NEXT(attrlist)) != NULL) {
		/* log to accounting_logs only if there's a value */
		if (strlen(pal->al_value) > 0)
			if (concat_rescused_to_buffer(buf, len, pal, " ", NULL, 1) != 0)
				return; 
		delete_link(&pal->al_link);
		(void)free(pal);
	}
	return;
}

/**
 * @brief
 * acct_open() - open the acct file for append.
 * Opens a (new) acct file.
 * If a acct file is already open, and the new file is successfully opened,
 * the old file is closed.  Otherwise the old file is left open.
 *
 * @param[in]	filename - abs pathname or NULL
 *
 * @return      Error code
 * @retval	 0  - Success
 * @retval	-1  - Failure
 */
int
acct_open(char *filename)
{

#ifdef WIN32
	char  filen[_MAX_PATH];
	char  logmsg[_MAX_PATH+80];
#else
	char  filen[_POSIX_PATH_MAX];
	char  logmsg[_POSIX_PATH_MAX+80];
#endif
	FILE *newacct;
	time_t now;
	struct tm *ptm;

	if (acct_buf == NULL) {	/* malloc buffer space */
		acct_buf = (char *)malloc(acct_bufsize+1);
		if (acct_buf == NULL)
			return (-1);
	}

	if (filename == NULL) {	/* go with default */
		now = time(0);
		ptm = localtime(&now);
		(void)sprintf(filen, "%s%04d%02d%02d",
			path_acct,
			ptm->tm_year+1900, ptm->tm_mon+1, ptm->tm_mday);
		filename = filen;
		acct_auto_switch = 1;
		acct_opened_day = ptm->tm_yday;
	} else if (*filename == '\0') {	/* a null name is not an error */
		return (0);		/* turns off account logging.  */
	} else if (*filename != '/') {
		return (-1);		/* not absolute */
	}
	if ((newacct = fopen(filename, "a")) == NULL) {
		log_err(errno, "acct_open", filename);
		return (-1);
	}

#ifdef WIN32
	secure_file(filename, "Administrators", READS_MASK|WRITES_MASK|STANDARD_RIGHTS_REQUIRED);
	(void)setvbuf(newacct, NULL, _IONBF, 0); /* no buffering to get instant
						  log*/
#else
	(void)setvbuf(newacct, NULL, _IOLBF, 0); /* set line buffering */
#endif

	if (acct_opened > 0) 		/* if acct was open, close it */
		(void)fclose(acctfile);

	acctfile = newacct;
	acct_opened = 1;			/* note that file is open */
	(void)sprintf(logmsg, "Account file %s opened", filename);
	log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, LOG_INFO,
		"Act", logmsg);

	return (0);
}

/**
 * @brief
 * acct_close - close the current open log file
 *
 * @return	void
 */
void
acct_close()
{
	if (acct_opened == 1) {
		(void)fclose(acctfile);
		acct_opened = 0;
	}
}

/**
 * @brief
 * write_account_record - write basic accounting record
 *
 * @param[in]	acctype - accounting record type
 * @param[in]	id - accounting record id
 * @param[in,out]	text - text to log, may be null
 *
 * @return	void
 */
void
write_account_record(int acctype, char *id, char *text)
{
	struct tm *ptm;

	if (acct_opened == 0)
		return;		/* file not open, don't bother */

	ptm = localtime(&time_now);

	/* Do we need to switch files */

	if (acct_auto_switch && (acct_opened_day != ptm->tm_yday)) {
		acct_close();
		acct_open(NULL);
	}
	if (text == NULL)
		text = "";

	(void)fprintf(acctfile,
		"%02d/%02d/%04d %02d:%02d:%02d;%c;%s;%s\n",
		ptm->tm_mon+1, ptm->tm_mday, ptm->tm_year+1900,
		ptm->tm_hour, ptm->tm_min, ptm->tm_sec,
		(char)acctype, id, text);
}

/**
 * @brief
 *account_record - basic job related accounting record
 *
 * @param[in]	acctype - accounting record type
 * @param[in]	pjob - pointer to job
 * @param[in]	text - text to log, may be null
 *
 * @return	void
 */
void
account_record(int acctype, job *pjob, char *text)
{
	write_account_record(acctype, pjob->ji_qs.ji_jobid, text);
}

/**
 * @brief
 * account_recordResv - write basic accounting record
 *
 * @param[in]	acctype - accounting record type
 * @param[in]	presv - pointer to reservation structure
 * @param[in]	text - text to log, may be null
 *
 * @return	void
 */
void
account_recordResv(int acctype, resc_resv *presv, char *text)
{
	write_account_record(acctype, presv->ri_qs.ri_resvID, text);
}

/**
 * @brief
 *	Form and write a job start record.
 *
 * @par	Functionality:
 *	Calls account_jobstr2().
 *
 * @see:
 *	complete_running()
 *
 * @param[in]	pjob	- pointer to job structure
 *
 * @return	void
 *
 * @par	MT-safe: No - uses a global buffer, "acct_buf".
 *
 */
void
account_jobstr(pjob)
job	*pjob;
{
	account_jobstr2(pjob, PBS_ACCT_RUN);
}

/**
 * @brief
 *	Form and write a record that contains basic job information and the
 *	assigned consumable resource values for the job.
 *
 * @par	Functionality:
 *	Takes various information from the job structure, start time, owner,
 *	Resource_List, etc., and the resource assigned information (based on
 *	job's exec_vnode value) and formats the record type requested.
 *	Currently, this is used for 'R' (Job run/started).
 *
 *	The record is then written to the accounting log.
 *
 * @see:
 *	complete_running()
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	type	- record type, PBS_ACCT_RUN ('R'),
 *					PBS_ACCT_NEXT ('c').
 * @return	void
 *
 * @par	MT-safe: No - uses a global buffer, "acct_buf".
 *
 */
void
account_jobstr2(job *pjob, int type)
{
	pbs_list_head attrlist;
	svrattrl *pal;

	CLEAR_HEAD(attrlist);

	/* pack in general information about the job */

	acct_buf[0] = '\0';
	acct_job(pjob, type, &acct_buf, &acct_bufsize);

	sum_resc_alloc(pjob, &attrlist);

	while((pal = GET_NEXT(attrlist)) != NULL) {
		/* log to accounting_logs only if there's a value */
		if (strlen(pal->al_value) > 0)
			if (concat_rescused_to_buffer(&acct_buf, &acct_bufsize, pal, " ", pjob, 1) != 0)
				return;
		delete_link(&pal->al_link);
		(void)free(pal);
	}
	account_record(type, pjob, acct_buf);
}

/**
 * @brief
 * account_resvstart - write a "reservation start" record
 *
 * @param[in]	presv - pointer to reservation structure
 *
 * @return	void
 */
void
account_resvstart(resc_resv *presv)
{
	/* pack in general information about the reservation */

	acct_buf[0] = '\0';
	(void)acct_resv(presv, &acct_buf, &acct_bufsize);
	account_recordResv(PBS_ACCT_BR, presv, acct_buf);
}

/**
 * @brief
 *	Form and write a job termination/rerun record with resource usage.
 *
 * @par	Functionality:
 *	Takes various information from the job structure, start time, owner,
 *	Resource_List, etc., and the resource usage information (see
 *	ji_acctresc) if present and formats the record type requested.
 *	Currently, this is used for 'E' and 'R' records.  The record is then
 *	written to the accounting log.
 *
 * @see:
 *	on_job_exit() and on_job_rerun() as well as force_reque().
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	used	- resource usage information from Mom,  this is a string
 *			  consisting of space separated keyword=value pairs,
 *			  may be null pointer
 * @param[in]	type	- record type, PBS_ACCT_END ('E') or
 *			  PBS_ACCT_RERUN ('R')
 * @return	void
 *
 * @par	MT-safe: No - uses a global buffer, "acct_buf".
 *
 */
void
account_jobend(job *pjob, char *used, int type)
{
	pbs_list_head   temp_head;
	struct          svrattrl *patlist = NULL;
	int             resc_used_size = 0;
	char		*str = NULL;
	char		errtime[] = "00:00:00";
	char		*resc_used;
#ifdef WIN32
	char		*win_str = NULL;
#endif
	char		tempstr[40] = {0};

	CLEAR_HEAD(temp_head);
	/* pack in general information about the job */

	acct_buf[0] = '\0';
	acct_job(pjob, type, &acct_buf, &acct_bufsize);

	/* session */
	snprintf(tempstr, sizeof(tempstr), " session=%ld",
		pjob->ji_wattr[(int)JOB_ATR_session_id].at_val.at_long);
	if (!pbs_strcat(&acct_buf, &acct_bufsize, tempstr))
		return;

	/* Alternate id if present */

	if (pjob->ji_wattr[(int)JOB_ATR_altid].at_flags & ATR_VFLAG_SET) {
#ifdef WIN32
		win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str, acctlog_spacechar);
		if (cpy_quote_value(&acct_buf, &acct_bufsize, win_str, JOB_ALTID_FMT) == -1)
			return;
#else
		if (cpy_quote_value(&acct_buf, &acct_bufsize, pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str, JOB_ALTID_FMT) == -1)
			return;
#endif
	}

	/* add the execution ended time */
	snprintf(tempstr, sizeof(tempstr), " end=%ld", (long)time_now);
	if (!pbs_strcat(&acct_buf, &acct_bufsize, tempstr))
		return;

	/* finally add on resources used from req_jobobit() */
	if (type == PBS_ACCT_END || type == PBS_ACCT_RERUN) {
		if ((used == NULL && pjob->ji_acctrec == NULL) || (used != NULL && strstr(used, "resources_used") == NULL)) {
			/* If pbs_server is restarted during the end of job processing then used maybe NULL.
			 * So we try to derive the resource usage information from resources_used attribute of
			 * the job and then reconstruct the resources usage information into resc_used buffer.
			 */
			if (pjob->ji_wattr[(int) JOB_ATR_resc_used].at_user_encoded != NULL)
				patlist = pjob->ji_wattr[(int) JOB_ATR_resc_used].at_user_encoded;
			else if (pjob->ji_wattr[(int) JOB_ATR_resc_used].at_priv_encoded != NULL)
				patlist = pjob->ji_wattr[(int) JOB_ATR_resc_used].at_priv_encoded;
			else
				encode_resc(&pjob->ji_wattr[(int) JOB_ATR_resc_used],
					    &temp_head, job_attr_def[(int) JOB_ATR_resc_used].at_name,
					    NULL, ATR_ENCODE_CLIENT, &patlist);

			/* Allocate initial space for resc_used.  Future space will be allocated by pbs_strcat(). */
			resc_used = malloc(RESC_USED_BUF_SIZE);
			if (resc_used == NULL)
				goto writeit;
			resc_used_size = RESC_USED_BUF_SIZE;


			/* strlen(msg_job_end_stat) == 12 characters plus a number.  This should be plenty big */
			(void) snprintf(resc_used, resc_used_size, msg_job_end_stat,
					pjob->ji_qs.ji_un.ji_exect.ji_exitstat);

			/*
			 * NOTE:
			 * Following code for constructing resources used information is same as job_obit()
			 * with minor different that to traverse patlist in this code
			 * we have to use patlist->al_sister since it is encoded information in job struct
			 * where in job_obit() we are using GET_NEXT(patlist->al_link) which is part of batch
			 * request.
			 * ji_acctrec is lost on server restart.  Recreate it here if needed.
			 */

			while(patlist) {
				/* log to accounting_logs only if there's a value */
				if (strlen(patlist->al_value) > 0) {
					if (concat_rescused_to_buffer(&resc_used, &resc_used_size, patlist, " ", NULL, 1) != 0) {
						free(resc_used);
						goto writeit;
					}
				}
				patlist = patlist->al_sister;
			}

			used = resc_used;
			free(pjob->ji_acctrec);
			pjob->ji_acctrec = used;
			free_attrlist(&temp_head);
		}
	}

	if (used != NULL) {
		if (!pbs_strcat(&acct_buf, &acct_bufsize, " "))
			goto writeit;
		if (!pbs_strcat(&acct_buf, &acct_bufsize, used))
			goto writeit;
	}

	/* Add eligible_time */
	if (server.sv_attr[(int)SRV_ATR_EligibleTimeEnable].at_val.at_long == 1) {
		str = convert_long_to_time(pjob->ji_wattr[(int)JOB_ATR_eligible_time].at_val.at_long);
		if (str == NULL)
			str = errtime;
		snprintf(tempstr, sizeof(tempstr), " eligible_time=%s ", str);
		if (!pbs_strcat(&acct_buf, &acct_bufsize, tempstr))
			goto writeit;
		if (str != NULL && str != errtime)
			free(str);
	}

	/* Add in run count */
	snprintf(tempstr, sizeof(tempstr), "%ld",
		pjob->ji_wattr[(int)JOB_ATR_runcount].at_val.at_long);
	if (cpy_quote_value(&acct_buf, &acct_bufsize, tempstr, RUNCOUNT_FMT) == -1)
		return;
	/* done creating record,  now write it out */

writeit:
	acct_buf[acct_bufsize-1] = '\0';
	account_record(type, pjob, acct_buf);
}
/**
 * @brief
 *	Log the license used.
 *
 * @see
 *	call_log_license
 *
 * @param[in]   pu	-	pointer to license_used
 *
 * @return      void
 */
void
log_licenses(struct license_used *pu)
{
	sprintf(acct_buf, "floating license hour:%d day:%d month:%d max:%d",
		pu->lu_max_hr,
		pu->lu_max_day,
		pu->lu_max_month,
		pu->lu_max_forever);
	write_account_record(PBS_ACCT_LIC, "license", acct_buf);
}

/**
 * @brief
 *	Builds job accounting record.
 *
 * @par Functionality:
 *      This function builds basic job data to be printed with provisioning
 *	record.
 *
 * @see
 *	set_job_ProvAcctRcd
 *
 * @param[in]   pjob	-	pointer to job
 * @param[in,out]   buf	-	pointer to buffer to contain job related data
 * @param[in]   len	-	pointer to the length of buffer
 *
 * @return      void.
 *
 * @par Side Effects:
 *     the accounting buffer (acct_buf) is grown
 *
 * @par MT-safe: No
 *
 */
static void
common_acct_job(job *pjob, char **buf, int *len)
{
#ifdef WIN32
	char	*win_str;
	/* user */
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, acctlog_spacechar);
	if (cpy_quote_value(buf, len, win_str, USER_FMT) == -1)
		return;
#else
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, USER_FMT) == -1)
		return;
#endif

	/* group */
#ifdef WIN32
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str, acctlog_spacechar);
	if (cpy_quote_value(buf, len, win_str, GROUP_FMT) == -1)
		return;
#else
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str, GROUP_FMT) == -1)
		return;
#endif

	/* job name */
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str, JOBNAME_FMT) == -1)
		return;

	/* queue name */
	cpy_quote_value(buf, len, pjob->ji_qhdr->qu_qs.qu_name, QUEUE_FMT);

	return;
}

/**
 * @brief
 *	Creates start/end provisioning record.
 *
 * @par Functionality:
 *      This function creates start/end provisioning record for a single job.
 *
 * @see
 *
 * @param[in]   pjob	-	pointer to job
 * @param[in]   time_se	-	start or end time stamp depending upon value of type
 * @param[in]   type	-	integer value to select type of record,
 *				1 = start, 2 = end
 *
 * @return	void
 *
 * @par Side Effects:
 *      The accounting buffer (acct_buf) is grown
 *
 * @par MT-safe: No
 *
 */
void
set_job_ProvAcctRcd(job *pjob, long time_se, int type)
{
	char	tempstr[60] = {0};

	/* pack in general information about the job */

	acct_buf[0] = '\0';
	common_acct_job(pjob, &acct_buf, &acct_bufsize);

	/* node list that were provisioned */
#ifdef NAS /* localmod 136 */
	if (pjob->ji_wattr[(int)JOB_ATR_prov_vnode].at_val.at_str == NULL) {
		char  logmsg[1024];
		(void)sprintf(logmsg, "prov_vnode is NULL for job %s", pjob->ji_wattr[(int)JOB_ATR_hashname].at_val.at_str);
		log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, LOG_INFO, "Bug", logmsg);

		return;
	}
#endif /* localmod 136 */
	if (cpy_quote_value(&acct_buf, &acct_bufsize, pjob->ji_wattr[(int)JOB_ATR_prov_vnode].at_val.at_str, PROV_NODE_FMT) == -1)
		return;

	switch (type) {
		case PROVISIONING_STARTED:
			(void)snprintf(tempstr, sizeof(tempstr), " provision_event=START start_time=%ld", time_se);
			pbs_strcat(&acct_buf, &acct_bufsize, tempstr);
			account_record(PBS_ACCT_PROV_START, pjob, acct_buf);
			break;
		case PROVISIONING_SUCCESS:
		case PROVISIONING_FAILURE:
			(void)snprintf(tempstr, sizeof(tempstr), "provision_event=END status=%s end_time=%ld", (type==2)?"SUCCESS":"FAILURE", time_se);
			pbs_strcat(&acct_buf, &acct_bufsize, tempstr);
			account_record(PBS_ACCT_PROV_END, pjob, acct_buf);
			break;
	}

}

/**
 * @brief
 * 	Build common data for update job accounting record
 *
 * @par	Functionality:
 *	Used by account_job_update()
 *
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	type	- type of accounting record: PBS_ACCT_UPDATE,
 *			  PBS_ACCT_LAST.
 * @param[in]	buf	- buffer holding the data that will be stored in
 *			  accounting logs.
 * @param[in]	len	- pointer to number of characters in 'buf' still 
 * 			  available to store data.
 * @return	void
 *
 */
static void
build_common_data_for_job_update(job *pjob, int type, char **buf, int *len)
{
	pbs_list_head	attrlist;
	svrattrl	*pal = NULL;
	int		k = 0;
	int		len_acct = 0;
	int		att_index = 0;
	int             old_perm = 0;
	char		save_char = 0;
	char		timestr[ACCTBUF_TIMES_NEED];
#ifdef WIN32
	char	*win_str = NULL;
#endif

	CLEAR_HEAD(attrlist);

	/* gridname */
	if (pjob->ji_wattr[(int)JOB_ATR_gridname].at_flags & ATR_VFLAG_SET) {
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_gridname].at_val.at_str, GRIDNAME_FMT) == -1)
			return;
		if (!pbs_strcat(buf, len, " "))
			return;
	}

	/* user */
#ifdef WIN32
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, acctlog_spacechar);
	if (cpy_quote_value(buf, len, win_str, USER_FMT) == -1)
		return;
#else
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_euser].at_val.at_str, USER_FMT) == -1)
		return;
#endif

	/* group */
#ifdef WIN32
	win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str, acctlog_spacechar);
	if (cpy_quote_value(buf, len, win_str, GROUP_FMT) == -1)
		return;
#else
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_egroup].at_val.at_str, GROUP_FMT) == -1)
		return;
#endif

	/* account */
	if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET) {
#ifdef WIN32
		win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str, acctlog_spacechar);
		if (cpy_quote_value(buf, len, win_str, ACCOUNT_FMT) == -1)
			return;
#else
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str, ACCOUNT_FMT) == -1)
			return;
#endif
	}

	/* project */
	if (pjob->ji_wattr[(int)JOB_ATR_project].at_flags & ATR_VFLAG_SET) {
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_project].at_val.at_str, PROJECT_FMT) == -1)
			return;
	}

	/* accounting_id */
	if (pjob->ji_wattr[(int)JOB_ATR_acct_id].at_flags & ATR_VFLAG_SET) {
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_acct_id].at_val.at_str, ACCOUNTING_ID_FMT) == -1)
			return;
	}

	/* job name */
	if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str, JOBNAME_FMT) == -1)
		return;

	/* queue name */
	if (cpy_quote_value(buf, len, pjob->ji_qhdr->qu_qs.qu_name, QUEUE_FMT) == -1)
		return;

	if (pjob->ji_myResv) {
		/* reservation name */
		if (pjob->ji_myResv->ri_wattr[(int)RESV_ATR_resv_name].at_flags
			& ATR_VFLAG_SET) {
			if (cpy_quote_value(buf, len, pjob->ji_myResv->ri_wattr[(int)RESV_ATR_resv_name].at_val.at_str, RESVNAME_FMT) == -1)
				return;
		}
		/* reservation ID */
		if (cpy_quote_value(buf, len, pjob->ji_myResv->ri_qs.ri_resvID, RESVID_FMT) == -1)
			return;
	}

	if (pjob->ji_resvp) {
		/* resvjob ID */
		if (cpy_quote_value(buf, len, pjob->ji_resvp->ri_qs.ri_resvID, RESVJOBID_FMT) == -1)
			return;
	}

	/* create time, queued time, eligible time, how long ready to run, and execution start time */
	snprintf(timestr, ACCTBUF_TIMES_NEED,
		 " ctime=%ld qtime=%ld etime=%ld start=%ld",
		 pjob->ji_wattr[(int)JOB_ATR_ctime].at_val.at_long,
		 pjob->ji_wattr[(int)JOB_ATR_qtime].at_val.at_long,
		 pjob->ji_wattr[(int)JOB_ATR_etime].at_val.at_long,
		 (long)pjob->ji_qs.ji_stime);
	if (!pbs_strcat(buf, len, timestr))
		return;

	if ((pjob->ji_wattr[(int)JOB_ATR_array_indices_submitted].at_flags & ATR_VFLAG_SET) && (pjob->ji_qs.ji_state == JOB_STATE_BEGUN)) {

		/* for an Array Job in Begun state,  record index range */
		if (cpy_quote_value(buf, len, pjob->ji_wattr[(int)JOB_ATR_array_indices_submitted].at_val.at_str, ARRAY_INDICES_FMT) == -1)
			return;

		/* now encode the job's resource_list attribute */
		/* of the just concluded phase */
		old_perm = resc_access_perm;
		resc_access_perm = READ_ONLY;
		if (type == PBS_ACCT_UPDATE)
			att_index = JOB_ATR_resource_acct;
		else
			att_index = JOB_ATR_resource;

		(void)job_attr_def[att_index].at_encode(
			&pjob->ji_wattr[att_index],
			&attrlist,
			job_attr_def[att_index].at_name,
			NULL,
			ATR_ENCODE_CLIENT, NULL);
		resc_access_perm = old_perm;

		if (type == PBS_ACCT_UPDATE)
			len_acct = 5; /* for length of "_acct" */
		else
			len_acct = 0;

		while ((pal = GET_NEXT(attrlist)) != NULL) {
			/* strip off the '_acct' suffix */
			if (len_acct > 0) {
				k = strlen(pal->al_name);
				if (k  > len_acct) {
					save_char = pal->al_name[k-len_acct];
					pal->al_name[k-len_acct] = '\0';
				}
			}

			if (strlen(pal->al_value) > 0)
				if (concat_rescused_to_buffer(buf, len, pal, " ", pjob, 1) != 0)
					return; 

			if (len_acct > 0) {
				if (k  > len_acct) {
					pal->al_name[k-len_acct] = save_char;
				}
			}
			delete_link(&pal->al_link);
			(void)free(pal);
		}
	} else {

		/* regular job */
		/* record exec_host of a completed phase */
		if (type == PBS_ACCT_UPDATE)
			att_index = JOB_ATR_exec_host_acct;
		else
			att_index = JOB_ATR_exec_host;

		if (pjob->ji_wattr[att_index].at_flags & ATR_VFLAG_SET) {
			/* execution host list, may be loooong */
			if (cpy_quote_value(buf, len, pjob->ji_wattr[att_index].at_val.at_str, EXEC_HOST_FMT) == -1)
				return;
		}

		/* record exec_vnode of a just concluded phase */
		if (type == PBS_ACCT_UPDATE)
			att_index = JOB_ATR_exec_vnode_acct;
		else
			att_index = JOB_ATR_exec_vnode;

		if (pjob->ji_wattr[att_index].at_flags & ATR_VFLAG_SET) {
			/* execution vnode list, will be even longer */
			if (cpy_quote_value(buf, len, pjob->ji_wattr[att_index].at_val.at_str, EXEC_VNODE_FMT) == -1)
				return;
		}

		/* now encode the job's resource_list attribute */
		/* of the just concluded phase */
		old_perm = resc_access_perm;
		resc_access_perm = READ_ONLY;
		if (type == PBS_ACCT_UPDATE)
			att_index = JOB_ATR_resource_acct;
		else
			att_index = JOB_ATR_resource;

		(void)job_attr_def[att_index].at_encode(
			&pjob->ji_wattr[att_index],
			&attrlist,
			job_attr_def[att_index].at_name,
			NULL,
			ATR_ENCODE_CLIENT, NULL);
		resc_access_perm = old_perm;
	
		pal = GET_NEXT(attrlist);
	
		if (type == PBS_ACCT_UPDATE)
			len_acct = 5; /* for length of "_acct" */
		else
			len_acct = 0;	

		while ((pal = GET_NEXT(attrlist)) != NULL) {
			/* strip off the '_acct' suffix */
			if (len_acct > 0) {
				k = strlen(pal->al_name);
				if (k  > len_acct) {
					save_char = pal->al_name[k-len_acct];
					pal->al_name[k-len_acct] = '\0';
				}
			}

			if (strlen(pal->al_value) > 0)
				if (concat_rescused_to_buffer(buf, len, pal, " ", pjob, 1) != 0)
					return;

			if (len_acct > 0) {
				if (k > len_acct) {
					pal->al_name[k-len_acct] = save_char;
				}
			}
			delete_link(&pal->al_link);
			(void)free(pal);
		}

	}
}

/**
 * @brief
 *	Form and write a job update record with resource usage.
 *
 * @par	Functionality:
 *	Takes various information from the job structure, start time, owner,
 *	Resource_List, etc., and the resource usage information
 *	if present and formats the record type requested.
 *	Currently, this is used for 'u' and 'e' records.  The record is then
 *	written to the accounting log.
 *
 * @see build_common_data_for_job_update()
 *
 * @param[in]	pjob	- pointer to job structure
 * @param[in]	used	- resource usage information from Mom,
 *			  this is a string consisting of space separated
 *			  keyword=value pairs, may be null pointer
 * @param[in]	type	- record type, PBS_ACCT_UPDATE ('u') or PBS_ACCT_LAST ('e')
 * @return	void
 *
 * @par	MT-safe: No - uses a global buffer, "acct_buf".
 *
 */
void
account_job_update(job *pjob, int type)
{
	int		len = 0;
	char		errtime[] = "00:00:00";
	char		*str = NULL;
	pbs_list_head	attrlist;
	struct svrattrl	*patlist = NULL;
	int		k = 0;
	int		len_upd = 0;	
	char		save_char = 0;
	int		old_perm = 0;
	char		tempstr[40];
#ifdef WIN32
	char	*win_str = NULL;
#endif

	if ((pjob->ji_wattr[(int)JOB_ATR_exec_vnode_acct].at_flags & ATR_VFLAG_SET) == 0) {
		return;
	}

	CLEAR_HEAD(attrlist);
	/* pack in general information about the job */

	build_common_data_for_job_update(pjob, type, &acct_buf, &acct_bufsize);

	/* session */
	snprintf(tempstr, sizeof(tempstr), " session=%ld",
		pjob->ji_wattr[(int)JOB_ATR_session_id].at_val.at_long);
	if (!pbs_strcat(&acct_buf, &acct_bufsize, tempstr))
		return;

	/* Alternate id if present */

	if (pjob->ji_wattr[(int)JOB_ATR_altid].at_flags & ATR_VFLAG_SET) {
#ifdef WIN32
		win_str = replace_space(pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str, acctlog_spacechar);
		if (cpy_quote_value(&acct_buf, &acct_bufsize, win_str, JOB_ALTID_FMT) == -1)
			return;
#else
		if (cpy_quote_value(&acct_buf, &acct_bufsize, pjob->ji_wattr[(int)JOB_ATR_altid].at_val.at_str, JOB_ALTID_FMT) == -1)
			return;
#endif
	}

	/* Add eligible_time */
	if (server.sv_attr[(int)SRV_ATR_EligibleTimeEnable].at_val.at_long == 1) {
		str = convert_long_to_time(pjob->ji_wattr[(int)JOB_ATR_eligible_time].at_val.at_long);
		if (str == NULL)
			str = errtime;
		snprintf(tempstr, sizeof(tempstr), " eligible_time=%s", str);
		if (!pbs_strcat(&acct_buf, &acct_bufsize, tempstr))
			goto writeit;
		if (str != NULL && str != errtime)
			free(str);
	}

	/* Add in runcount */

	snprintf(tempstr, sizeof(tempstr), "%ld",
		pjob->ji_wattr[(int)JOB_ATR_runcount].at_val.at_long);
	if (cpy_quote_value(&acct_buf, &acct_bufsize, tempstr, RUNCOUNT_FMT) == -1)
		return;

	/* now encode the job's resources_used attribute */
	old_perm = resc_access_perm;
	resc_access_perm = READ_ONLY;
	(void)job_attr_def[(int)JOB_ATR_resc_used_update].at_encode(
			&pjob->ji_wattr[(int)JOB_ATR_resc_used_update],
			&attrlist,
			job_attr_def[(int)JOB_ATR_resc_used_update].at_name,
			NULL,
			ATR_ENCODE_CLIENT, NULL);
	resc_access_perm = old_perm;

	patlist = GET_NEXT(attrlist);
	len_upd = 7; /* for length of "_update" */
	while (patlist) {
		/* strip off the '_update' suffix */
		k = strlen(patlist->al_name);
		if (k > len_upd) {
			save_char = patlist->al_name[k-len_upd];
			patlist->al_name[k-len_upd] = '\0';
		}
		/*
		 * To calculate length of the string of the form "resources_used.<resource>=<value>".
		 * Additional length of 3 is required to accommodate the characters '.', '=' and ' '.
		 */
		if (strlen(patlist->al_value) > 0) {
			if (strlen(patlist->al_value) > 0)
				if (concat_rescused_to_buffer(&acct_buf, &len, patlist, " ", pjob, 1) != 0)
					return; 

			if (k > len_upd) {
				patlist->al_name[k-len_upd] = save_char;
			}
		}
		patlist = patlist->al_sister;
	}
	free_attrlist(&attrlist);

	if ((pjob->ji_wattr[JOB_ATR_resc_used_acct].at_flags & ATR_VFLAG_SET) != 0) {
		job_attr_def[JOB_ATR_resc_used_acct].at_free(&pjob->ji_wattr[JOB_ATR_resc_used_acct]);
		pjob->ji_wattr[JOB_ATR_resc_used_acct].at_flags &= ~ATR_VFLAG_SET;
	}
	job_attr_def[JOB_ATR_resc_used_acct].at_set( &pjob->ji_wattr[JOB_ATR_resc_used_acct], &pjob->ji_wattr[JOB_ATR_resc_used], INCR);

writeit:
	acct_buf[acct_bufsize-1] = '\0';
	account_record(type, pjob, acct_buf);
}

